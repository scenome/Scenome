////////////////////////////////////////////////////////////////////////////////
//
// $file             TEMPLATE_UTIL.SSL
// $author           Scenomics LLC
// $description      This script contains functions generated from templates in meta_util.ssl.
//
// Copyright 2004-2014 Scenomics LLC. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

import library "enumeration_util.ssl";
import library "message_util.ssl";
import library "opengl_util.ssl";
library Template;

// This library is automatically generated by CompileTemplateFunctions() in META_UTIL.SSL. Local changes will be destroyed.

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function int ConvertBindingToQualifier( int p_iBindingType )
{
   if( p_iBindingType == Enum.Binding_Local() )
   {
      return -1;
   }
   else
   if( p_iBindingType == Enum.Binding_Constant() )
   {
      return Enum.GLSL_Qualifier_Const();
   }
   else
   if( p_iBindingType == Enum.Binding_Uniform() )
   {
      return Enum.GLSL_Qualifier_Uniform();
   }
   else
   if( p_iBindingType == Enum.Binding_Attribute() )
   {
      return Enum.GLSL_Qualifier_Attribute();
   }
   else
   if( p_iBindingType == Enum.Binding_Varying() )
   {
      return Enum.GLSL_Qualifier_Varying();
   }
   else
   if( p_iBindingType == Enum.Binding_CompileDirective() )
   {
      return Enum.GLSL_Qualifier_CompileDirective();
   }
   else
   if( p_iBindingType == Enum.Binding_Input() )
   {
      return Enum.GLSL_Qualifier_In();
   }
   else
   if( p_iBindingType == Enum.Binding_Output() )
   {
      return Enum.GLSL_Qualifier_Out();
   }
   else
   if( p_iBindingType == Enum.Binding_None() )
   {
      return -1;
   }
   else
   if( p_iBindingType == Enum.Binding_Buffer() )
   {
      return Enum.GLSL_Qualifier_Buffer();
   }
   else
   if( p_iBindingType == Enum.Binding_Subroutine() )
   {
      return Enum.GLSL_Qualifier_Subroutine();
   }

   return -1;
}
////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function string GetVariableName( VariableNode p_oVariableNode )
{
   if( p_oVariableNode.IsDerived( BooleanNode ) )
   {
      BooleanNode a_oBooleanNode = ( BooleanNode )p_oVariableNode;
      return a_oBooleanNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( BooleanArrayNode ) )
   {
      BooleanArrayNode a_oBooleanArrayNode = ( BooleanArrayNode )p_oVariableNode;
      return a_oBooleanArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( BooleanVectorNode ) )
   {
      BooleanVectorNode a_oBooleanVectorNode = ( BooleanVectorNode )p_oVariableNode;
      return a_oBooleanVectorNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( BooleanVectorArrayNode ) )
   {
      BooleanVectorArrayNode a_oBooleanVectorArrayNode = ( BooleanVectorArrayNode )p_oVariableNode;
      return a_oBooleanVectorArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( StringNode ) )
   {
      StringNode a_oStringNode = ( StringNode )p_oVariableNode;
      return a_oStringNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( StringArrayNode ) )
   {
      StringArrayNode a_oStringArrayNode = ( StringArrayNode )p_oVariableNode;
      return a_oStringArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( FloatNode ) )
   {
      FloatNode a_oFloatNode = ( FloatNode )p_oVariableNode;
      return a_oFloatNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( FloatArrayNode ) )
   {
      FloatArrayNode a_oFloatArrayNode = ( FloatArrayNode )p_oVariableNode;
      return a_oFloatArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( TimerNode ) )
   {
      TimerNode a_oTimerNode = ( TimerNode )p_oVariableNode;
      return a_oTimerNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( UnsignedIntegerNode ) )
   {
      UnsignedIntegerNode a_oUnsignedIntegerNode = ( UnsignedIntegerNode )p_oVariableNode;
      return a_oUnsignedIntegerNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( UnsignedIntegerArrayNode ) )
   {
      UnsignedIntegerArrayNode a_oUnsignedIntegerArrayNode = ( UnsignedIntegerArrayNode )p_oVariableNode;
      return a_oUnsignedIntegerArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( UnsignedIntegerVectorNode ) )
   {
      UnsignedIntegerVectorNode a_oUnsignedIntegerVectorNode = ( UnsignedIntegerVectorNode )p_oVariableNode;
      return a_oUnsignedIntegerVectorNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( UnsignedIntegerVectorArrayNode ) )
   {
      UnsignedIntegerVectorArrayNode a_oUnsignedIntegerVectorArrayNode = ( UnsignedIntegerVectorArrayNode )p_oVariableNode;
      return a_oUnsignedIntegerVectorArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( IntegerNode ) )
   {
      IntegerNode a_oIntegerNode = ( IntegerNode )p_oVariableNode;
      return a_oIntegerNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( IntegerArrayNode ) )
   {
      IntegerArrayNode a_oIntegerArrayNode = ( IntegerArrayNode )p_oVariableNode;
      return a_oIntegerArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( IntegerVectorNode ) )
   {
      IntegerVectorNode a_oIntegerVectorNode = ( IntegerVectorNode )p_oVariableNode;
      return a_oIntegerVectorNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( IntegerVectorArrayNode ) )
   {
      IntegerVectorArrayNode a_oIntegerVectorArrayNode = ( IntegerVectorArrayNode )p_oVariableNode;
      return a_oIntegerVectorArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( ColorNode ) )
   {
      ColorNode a_oColorNode = ( ColorNode )p_oVariableNode;
      return a_oColorNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( ColorArrayNode ) )
   {
      ColorArrayNode a_oColorArrayNode = ( ColorArrayNode )p_oVariableNode;
      return a_oColorArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( MatrixNode ) )
   {
      MatrixNode a_oMatrixNode = ( MatrixNode )p_oVariableNode;
      return a_oMatrixNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( VectorNode ) )
   {
      VectorNode a_oVectorNode = ( VectorNode )p_oVariableNode;
      return a_oVectorNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( VectorArrayNode ) )
   {
      VectorArrayNode a_oVectorArrayNode = ( VectorArrayNode )p_oVariableNode;
      return a_oVectorArrayNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( SamplerNode ) )
   {
      SamplerNode a_oSamplerNode = ( SamplerNode )p_oVariableNode;
      return a_oSamplerNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( StructInstanceNode ) )
   {
      StructInstanceNode a_oStructInstanceNode = ( StructInstanceNode )p_oVariableNode;
      return a_oStructInstanceNode.GetDeclarationString();
   }
   else
   if( p_oVariableNode.IsDerived( MatrixArrayNode ) )
   {
      MatrixArrayNode a_oMatrixArrayNode = ( MatrixArrayNode )p_oVariableNode;
      return a_oMatrixArrayNode.GetDeclarationString();
   }
   return "UNKNOWN_VARIABLE_TYPE";
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function int GetBindingTypeFromSelectionContext()
{
   int a_nBindingType = Enum.Binding_Local();
   for( int a_nSelIndex = 0; a_nSelIndex < Model.GetSelectCount(); ++a_nSelIndex )
   {
      Node a_oSelectedNode = (Node)Model.GetSelectedNode( a_nSelIndex ).GetNode();
      if(   a_oSelectedNode && a_oSelectedNode.IsDerived( UniformPaletteNode ) ||
            a_oSelectedNode && a_oSelectedNode.IsDerived( Program ) ||
            a_oSelectedNode && a_oSelectedNode.IsDerived( UniformArrayNode ) ||
            a_oSelectedNode && a_oSelectedNode.IsDerived( UniformBufferBindNode ) )
      {
         a_nBindingType = Enum.Binding_Uniform();
      }
   }
   return a_nBindingType;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureVariableNodeForSelectionContext( List p_lNodes, int p_iBindingType )
{
   for( int i = 0; i < p_lNodes.GetCount(); ++i )
   {
      VariableNode a_oVariableNode = (VariableNode)p_lNodes.Get( i );
      a_oVariableNode.BindingType = p_iBindingType;
      a_oVariableNode.QualifierList.ModifyQualifier( true, ConvertBindingToQualifier( p_iBindingType ) );
      a_oVariableNode.Name = GetVariableName( a_oVariableNode );
   }
}
////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsViewportFloatNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slViewportFloatNodeModes;
   auto ViewportFloatNode a_oViewportFloatNode;
   a_oViewportFloatNode.GetModeNames( a_slViewportFloatNodeModes );
   int a_iIndex = a_slViewportFloatNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsViewportVectorNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slViewportVectorNodeModes;
   auto ViewportVectorNode a_oViewportVectorNode;
   a_oViewportVectorNode.GetModeNames( a_slViewportVectorNodeModes );
   int a_iIndex = a_slViewportVectorNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsViewMatrixNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slViewMatrixNodeModes;
   auto ViewMatrixNode a_oViewMatrixNode;
   a_oViewMatrixNode.GetModeNames( a_slViewMatrixNodeModes );
   int a_iIndex = a_slViewMatrixNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightBooleanNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightBooleanNodeModes;
   auto LightBooleanNode a_oLightBooleanNode;
   a_oLightBooleanNode.GetModeNames( a_slLightBooleanNodeModes );
   int a_iIndex = a_slLightBooleanNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightIntegerNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightIntegerNodeModes;
   auto LightIntegerNode a_oLightIntegerNode;
   a_oLightIntegerNode.GetModeNames( a_slLightIntegerNodeModes );
   int a_iIndex = a_slLightIntegerNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightColorNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightColorNodeModes;
   auto LightColorNode a_oLightColorNode;
   a_oLightColorNode.GetModeNames( a_slLightColorNodeModes );
   int a_iIndex = a_slLightColorNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightVectorNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightVectorNodeModes;
   auto LightVectorNode a_oLightVectorNode;
   a_oLightVectorNode.GetModeNames( a_slLightVectorNodeModes );
   int a_iIndex = a_slLightVectorNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightFloatNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightFloatNodeModes;
   auto LightFloatNode a_oLightFloatNode;
   a_oLightFloatNode.GetModeNames( a_slLightFloatNodeModes );
   int a_iIndex = a_slLightFloatNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightMatrixNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightMatrixNodeModes;
   auto LightMatrixNode a_oLightMatrixNode;
   a_oLightMatrixNode.GetModeNames( a_slLightMatrixNodeModes );
   int a_iIndex = a_slLightMatrixNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsMaterialColorNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slMaterialColorNodeModes;
   auto MaterialColorNode a_oMaterialColorNode;
   a_oMaterialColorNode.GetModeNames( a_slMaterialColorNodeModes );
   int a_iIndex = a_slMaterialColorNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsMaterialIntegerNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slMaterialIntegerNodeModes;
   auto MaterialIntegerNode a_oMaterialIntegerNode;
   a_oMaterialIntegerNode.GetModeNames( a_slMaterialIntegerNodeModes );
   int a_iIndex = a_slMaterialIntegerNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsMaterialFloatNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slMaterialFloatNodeModes;
   auto MaterialFloatNode a_oMaterialFloatNode;
   a_oMaterialFloatNode.GetModeNames( a_slMaterialFloatNodeModes );
   int a_iIndex = a_slMaterialFloatNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsTimerNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slTimerNodeModes;
   auto TimerNode a_oTimerNode;
   a_oTimerNode.GetModeNames( a_slTimerNodeModes );
   int a_iIndex = a_slTimerNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsLightCountNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slLightCountNodeModes;
   auto LightCountNode a_oLightCountNode;
   a_oLightCountNode.GetModeNames( a_slLightCountNodeModes );
   int a_iIndex = a_slLightCountNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsRectanglePrimitiveVectorNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slRectanglePrimitiveVectorNodeModes;
   auto RectanglePrimitiveVectorNode a_oRectanglePrimitiveVectorNode;
   a_oRectanglePrimitiveVectorNode.GetModeNames( a_slRectanglePrimitiveVectorNodeModes );
   int a_iIndex = a_slRectanglePrimitiveVectorNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool IsSubroutineIntegerNodeMode( string p_sTitle, ref int p_iMode )
{
   bool a_bIsModeOf;
   auto StrList a_slSubroutineIntegerNodeModes;
   auto SubroutineIntegerNode a_oSubroutineIntegerNode;
   a_oSubroutineIntegerNode.GetModeNames( a_slSubroutineIntegerNodeModes );
   int a_iIndex = a_slSubroutineIntegerNodeModes.Find( p_sTitle );
   if( a_iIndex != -1 )
   {
      a_bIsModeOf = true;
      p_iMode = a_iIndex + 1;
   }
   return a_bIsModeOf;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ViewportFloatNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( ViewportFloatNode ) )
      {
         ViewportFloatNode a_oViewportFloatNode = (ViewportFloatNode)Model.EditNode( a_oNode );
         a_oViewportFloatNode.Mode = p_iMode;
         a_oViewportFloatNode.Name = GetVariableName( a_oViewportFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ViewportVectorNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( ViewportVectorNode ) )
      {
         ViewportVectorNode a_oViewportVectorNode = (ViewportVectorNode)Model.EditNode( a_oNode );
         a_oViewportVectorNode.Mode = p_iMode;
         a_oViewportVectorNode.Name = GetVariableName( a_oViewportVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ViewMatrixNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( ViewMatrixNode ) )
      {
         ViewMatrixNode a_oViewMatrixNode = (ViewMatrixNode)Model.EditNode( a_oNode );
         a_oViewMatrixNode.Mode = p_iMode;
         a_oViewMatrixNode.Name = GetVariableName( a_oViewMatrixNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightBooleanNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightBooleanNode ) )
      {
         LightBooleanNode a_oLightBooleanNode = (LightBooleanNode)Model.EditNode( a_oNode );
         a_oLightBooleanNode.Mode = p_iMode;
         a_oLightBooleanNode.Name = GetVariableName( a_oLightBooleanNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightIntegerNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightIntegerNode ) )
      {
         LightIntegerNode a_oLightIntegerNode = (LightIntegerNode)Model.EditNode( a_oNode );
         a_oLightIntegerNode.Mode = p_iMode;
         a_oLightIntegerNode.Name = GetVariableName( a_oLightIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightColorNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightColorNode ) )
      {
         LightColorNode a_oLightColorNode = (LightColorNode)Model.EditNode( a_oNode );
         a_oLightColorNode.Mode = p_iMode;
         a_oLightColorNode.Name = GetVariableName( a_oLightColorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightVectorNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightVectorNode ) )
      {
         LightVectorNode a_oLightVectorNode = (LightVectorNode)Model.EditNode( a_oNode );
         a_oLightVectorNode.Mode = p_iMode;
         a_oLightVectorNode.Name = GetVariableName( a_oLightVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightFloatNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightFloatNode ) )
      {
         LightFloatNode a_oLightFloatNode = (LightFloatNode)Model.EditNode( a_oNode );
         a_oLightFloatNode.Mode = p_iMode;
         a_oLightFloatNode.Name = GetVariableName( a_oLightFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightMatrixNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightMatrixNode ) )
      {
         LightMatrixNode a_oLightMatrixNode = (LightMatrixNode)Model.EditNode( a_oNode );
         a_oLightMatrixNode.Mode = p_iMode;
         a_oLightMatrixNode.Name = GetVariableName( a_oLightMatrixNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void MaterialColorNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( MaterialColorNode ) )
      {
         MaterialColorNode a_oMaterialColorNode = (MaterialColorNode)Model.EditNode( a_oNode );
         a_oMaterialColorNode.Mode = p_iMode;
         a_oMaterialColorNode.Name = GetVariableName( a_oMaterialColorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void MaterialIntegerNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( MaterialIntegerNode ) )
      {
         MaterialIntegerNode a_oMaterialIntegerNode = (MaterialIntegerNode)Model.EditNode( a_oNode );
         a_oMaterialIntegerNode.Mode = p_iMode;
         a_oMaterialIntegerNode.Name = GetVariableName( a_oMaterialIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void MaterialFloatNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( MaterialFloatNode ) )
      {
         MaterialFloatNode a_oMaterialFloatNode = (MaterialFloatNode)Model.EditNode( a_oNode );
         a_oMaterialFloatNode.Mode = p_iMode;
         a_oMaterialFloatNode.Name = GetVariableName( a_oMaterialFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void TimerNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( TimerNode ) )
      {
         TimerNode a_oTimerNode = (TimerNode)Model.EditNode( a_oNode );
         a_oTimerNode.Mode = p_iMode;
         a_oTimerNode.Name = GetVariableName( a_oTimerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void LightCountNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( LightCountNode ) )
      {
         LightCountNode a_oLightCountNode = (LightCountNode)Model.EditNode( a_oNode );
         a_oLightCountNode.Mode = p_iMode;
         a_oLightCountNode.Name = GetVariableName( a_oLightCountNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void RectanglePrimitiveVectorNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( RectanglePrimitiveVectorNode ) )
      {
         RectanglePrimitiveVectorNode a_oRectanglePrimitiveVectorNode = (RectanglePrimitiveVectorNode)Model.EditNode( a_oNode );
         a_oRectanglePrimitiveVectorNode.Mode = p_iMode;
         a_oRectanglePrimitiveVectorNode.Name = GetVariableName( a_oRectanglePrimitiveVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void SubroutineIntegerNodeSetMode( int p_iMode )
{
   for( int i = 0; i < Model.GetSelectCount(); ++i )
   {
      Node a_oNode = Model.GetSelectedNode( i ).GetNode();

      if( a_oNode.IsDerived( SubroutineIntegerNode ) )
      {
         SubroutineIntegerNode a_oSubroutineIntegerNode = (SubroutineIntegerNode)Model.EditNode( a_oNode );
         a_oSubroutineIntegerNode.Mode = p_iMode;
         a_oSubroutineIntegerNode.Name = GetVariableName( a_oSubroutineIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatViewportFloatNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( ViewportFloatNode ) )
   {
      ViewportFloatNode a_oViewportFloatNode = (ViewportFloatNode)p_oNode;
      a_oViewportFloatNode.Name = p_sNodeName;
      a_oViewportFloatNode.Class = p_sNodeClass;
      a_oViewportFloatNode.BindingType = p_nBindingType;
      a_oViewportFloatNode.Variable = p_sVariableName;
      a_oViewportFloatNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oViewportFloatNode.Name = GetVariableName( a_oViewportFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatViewportVectorNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iDimension, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( ViewportVectorNode ) )
   {
      ViewportVectorNode a_oViewportVectorNode = (ViewportVectorNode)p_oNode;
      a_oViewportVectorNode.Name = p_sNodeName;
      a_oViewportVectorNode.Class = p_sNodeClass;
      a_oViewportVectorNode.BindingType = p_nBindingType;
      a_oViewportVectorNode.Variable = p_sVariableName;
      a_oViewportVectorNode.Dimension = p_iDimension;
      a_oViewportVectorNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oViewportVectorNode.Name = GetVariableName( a_oViewportVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatViewMatrixNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iCols, int p_iRows, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( ViewMatrixNode ) )
   {
      ViewMatrixNode a_oViewMatrixNode = (ViewMatrixNode)p_oNode;
      a_oViewMatrixNode.Name = p_sNodeName;
      a_oViewMatrixNode.Class = p_sNodeClass;
      a_oViewMatrixNode.BindingType = p_nBindingType;
      a_oViewMatrixNode.Variable = p_sVariableName;
      a_oViewMatrixNode.Cols = p_iCols;
      a_oViewMatrixNode.Rows = p_iRows;
      a_oViewMatrixNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oViewMatrixNode.Name = GetVariableName( a_oViewMatrixNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightBooleanNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightBooleanNode ) )
   {
      LightBooleanNode a_oLightBooleanNode = (LightBooleanNode)p_oNode;
      a_oLightBooleanNode.Name = p_sNodeName;
      a_oLightBooleanNode.Class = p_sNodeClass;
      a_oLightBooleanNode.BindingType = p_nBindingType;
      a_oLightBooleanNode.Variable = p_sVariableName;
      a_oLightBooleanNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightBooleanNode.Name = GetVariableName( a_oLightBooleanNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightIntegerNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightIntegerNode ) )
   {
      LightIntegerNode a_oLightIntegerNode = (LightIntegerNode)p_oNode;
      a_oLightIntegerNode.Name = p_sNodeName;
      a_oLightIntegerNode.Class = p_sNodeClass;
      a_oLightIntegerNode.BindingType = p_nBindingType;
      a_oLightIntegerNode.Variable = p_sVariableName;
      a_oLightIntegerNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightIntegerNode.Name = GetVariableName( a_oLightIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightColorNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightColorNode ) )
   {
      LightColorNode a_oLightColorNode = (LightColorNode)p_oNode;
      a_oLightColorNode.Name = p_sNodeName;
      a_oLightColorNode.Class = p_sNodeClass;
      a_oLightColorNode.BindingType = p_nBindingType;
      a_oLightColorNode.Variable = p_sVariableName;
      a_oLightColorNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightColorNode.Name = GetVariableName( a_oLightColorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightVectorNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iDimension, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightVectorNode ) )
   {
      LightVectorNode a_oLightVectorNode = (LightVectorNode)p_oNode;
      a_oLightVectorNode.Name = p_sNodeName;
      a_oLightVectorNode.Class = p_sNodeClass;
      a_oLightVectorNode.BindingType = p_nBindingType;
      a_oLightVectorNode.Variable = p_sVariableName;
      a_oLightVectorNode.Dimension = p_iDimension;
      a_oLightVectorNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightVectorNode.Name = GetVariableName( a_oLightVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightFloatNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightFloatNode ) )
   {
      LightFloatNode a_oLightFloatNode = (LightFloatNode)p_oNode;
      a_oLightFloatNode.Name = p_sNodeName;
      a_oLightFloatNode.Class = p_sNodeClass;
      a_oLightFloatNode.BindingType = p_nBindingType;
      a_oLightFloatNode.Variable = p_sVariableName;
      a_oLightFloatNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightFloatNode.Name = GetVariableName( a_oLightFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightMatrixNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iCols, int p_iRows, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightMatrixNode ) )
   {
      LightMatrixNode a_oLightMatrixNode = (LightMatrixNode)p_oNode;
      a_oLightMatrixNode.Name = p_sNodeName;
      a_oLightMatrixNode.Class = p_sNodeClass;
      a_oLightMatrixNode.BindingType = p_nBindingType;
      a_oLightMatrixNode.Variable = p_sVariableName;
      a_oLightMatrixNode.Cols = p_iCols;
      a_oLightMatrixNode.Rows = p_iRows;
      a_oLightMatrixNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightMatrixNode.Name = GetVariableName( a_oLightMatrixNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatMaterialColorNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( MaterialColorNode ) )
   {
      MaterialColorNode a_oMaterialColorNode = (MaterialColorNode)p_oNode;
      a_oMaterialColorNode.Name = p_sNodeName;
      a_oMaterialColorNode.Class = p_sNodeClass;
      a_oMaterialColorNode.BindingType = p_nBindingType;
      a_oMaterialColorNode.Variable = p_sVariableName;
      a_oMaterialColorNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oMaterialColorNode.Name = GetVariableName( a_oMaterialColorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatMaterialIntegerNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( MaterialIntegerNode ) )
   {
      MaterialIntegerNode a_oMaterialIntegerNode = (MaterialIntegerNode)p_oNode;
      a_oMaterialIntegerNode.Name = p_sNodeName;
      a_oMaterialIntegerNode.Class = p_sNodeClass;
      a_oMaterialIntegerNode.BindingType = p_nBindingType;
      a_oMaterialIntegerNode.Variable = p_sVariableName;
      a_oMaterialIntegerNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oMaterialIntegerNode.Name = GetVariableName( a_oMaterialIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatMaterialFloatNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( MaterialFloatNode ) )
   {
      MaterialFloatNode a_oMaterialFloatNode = (MaterialFloatNode)p_oNode;
      a_oMaterialFloatNode.Name = p_sNodeName;
      a_oMaterialFloatNode.Class = p_sNodeClass;
      a_oMaterialFloatNode.BindingType = p_nBindingType;
      a_oMaterialFloatNode.Variable = p_sVariableName;
      a_oMaterialFloatNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oMaterialFloatNode.Name = GetVariableName( a_oMaterialFloatNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatTimerNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( TimerNode ) )
   {
      TimerNode a_oTimerNode = (TimerNode)p_oNode;
      a_oTimerNode.Name = p_sNodeName;
      a_oTimerNode.Class = p_sNodeClass;
      a_oTimerNode.BindingType = p_nBindingType;
      a_oTimerNode.Variable = p_sVariableName;
      a_oTimerNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oTimerNode.Name = GetVariableName( a_oTimerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatLightCountNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( LightCountNode ) )
   {
      LightCountNode a_oLightCountNode = (LightCountNode)p_oNode;
      a_oLightCountNode.Name = p_sNodeName;
      a_oLightCountNode.Class = p_sNodeClass;
      a_oLightCountNode.BindingType = p_nBindingType;
      a_oLightCountNode.Variable = p_sVariableName;
      a_oLightCountNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oLightCountNode.Name = GetVariableName( a_oLightCountNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatRectanglePrimitiveVectorNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iDimension, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( RectanglePrimitiveVectorNode ) )
   {
      RectanglePrimitiveVectorNode a_oRectanglePrimitiveVectorNode = (RectanglePrimitiveVectorNode)p_oNode;
      a_oRectanglePrimitiveVectorNode.Name = p_sNodeName;
      a_oRectanglePrimitiveVectorNode.Class = p_sNodeClass;
      a_oRectanglePrimitiveVectorNode.BindingType = p_nBindingType;
      a_oRectanglePrimitiveVectorNode.Variable = p_sVariableName;
      a_oRectanglePrimitiveVectorNode.Dimension = p_iDimension;
      a_oRectanglePrimitiveVectorNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oRectanglePrimitiveVectorNode.Name = GetVariableName( a_oRectanglePrimitiveVectorNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void FormatSubroutineIntegerNode( Node p_oNode, string p_sNodeName, string p_sNodeClass, int p_nBindingType, string p_sVariableName, int p_iMode, bool p_bUpdateName )
{
   if( p_oNode.IsDerived( SubroutineIntegerNode ) )
   {
      SubroutineIntegerNode a_oSubroutineIntegerNode = (SubroutineIntegerNode)p_oNode;
      a_oSubroutineIntegerNode.Name = p_sNodeName;
      a_oSubroutineIntegerNode.Class = p_sNodeClass;
      a_oSubroutineIntegerNode.BindingType = p_nBindingType;
      a_oSubroutineIntegerNode.Variable = p_sVariableName;
      a_oSubroutineIntegerNode.Mode = p_iMode;
      if( p_bUpdateName )
      {
         a_oSubroutineIntegerNode.Name = GetVariableName( a_oSubroutineIntegerNode );
      }
   }
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateBooleanExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanExpressionNode a_oBooleanExpressionNodeLeft = new BooleanExpressionNode;
   a_oBooleanExpressionNodeLeft.Name = "Input A";
   a_oBooleanExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oBooleanExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanExpressionNode a_oBooleanExpressionNodeRight = new BooleanExpressionNode;
   a_oBooleanExpressionNodeRight.Name = "Input B";
   a_oBooleanExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oBooleanExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oBooleanExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBooleanExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oBooleanExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oBooleanExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oBooleanExpressionNodeLeft.GenerateExpression( BooleanExpressionGenerator );
   a_oBooleanExpressionNodeRight.GenerateExpression( BooleanExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oBooleanExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oBooleanExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateBooleanArrayExpressionNodeAssignment( int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanArrayExpressionNode a_oBooleanArrayExpressionNodeLeft = new BooleanArrayExpressionNode;
   a_oBooleanArrayExpressionNodeLeft.Name = "Input A";
   a_oBooleanArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oBooleanArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oBooleanArrayExpressionNodeLeft.Count = p_nArrayDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanArrayExpressionNode a_oBooleanArrayExpressionNodeRight = new BooleanArrayExpressionNode;
   a_oBooleanArrayExpressionNodeRight.Name = "Input B";
   a_oBooleanArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oBooleanArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oBooleanArrayExpressionNodeRight.Count = p_nArrayDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oBooleanArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBooleanArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oBooleanArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oBooleanArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oBooleanArrayExpressionNodeLeft.GenerateExpression( BooleanArrayExpressionGenerator );
   a_oBooleanArrayExpressionNodeRight.GenerateExpression( BooleanArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oBooleanArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oBooleanArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateBooleanVectorExpressionNodeAssignment( int p_nDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanVectorExpressionNode a_oBooleanVectorExpressionNodeLeft = new BooleanVectorExpressionNode;
   a_oBooleanVectorExpressionNodeLeft.Name = "Input A";
   a_oBooleanVectorExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oBooleanVectorExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oBooleanVectorExpressionNodeLeft.Dimension = p_nDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanVectorExpressionNode a_oBooleanVectorExpressionNodeRight = new BooleanVectorExpressionNode;
   a_oBooleanVectorExpressionNodeRight.Name = "Input B";
   a_oBooleanVectorExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oBooleanVectorExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oBooleanVectorExpressionNodeRight.Dimension = p_nDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oBooleanVectorExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBooleanVectorExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oBooleanVectorExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oBooleanVectorExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oBooleanVectorExpressionNodeLeft.GenerateExpression( BooleanVectorExpressionGenerator );
   a_oBooleanVectorExpressionNodeRight.GenerateExpression( BooleanVectorExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oBooleanVectorExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oBooleanVectorExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateBooleanVectorArrayExpressionNodeAssignment(int p_nVectorDimension, int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanVectorArrayExpressionNode a_oBooleanVectorArrayExpressionNodeLeft = new BooleanVectorArrayExpressionNode;
   a_oBooleanVectorArrayExpressionNodeLeft.Name = "Input A";
   a_oBooleanVectorArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oBooleanVectorArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oBooleanVectorArrayExpressionNodeLeft.Count = p_nArrayDimension;
   a_oBooleanVectorArrayExpressionNodeLeft.Dimension = p_nVectorDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   BooleanVectorArrayExpressionNode a_oBooleanVectorArrayExpressionNodeRight = new BooleanVectorArrayExpressionNode;
   a_oBooleanVectorArrayExpressionNodeRight.Name = "Input B";
   a_oBooleanVectorArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oBooleanVectorArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oBooleanVectorArrayExpressionNodeRight.Count = p_nArrayDimension;
   a_oBooleanVectorArrayExpressionNodeRight.Dimension = p_nVectorDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oBooleanVectorArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBooleanVectorArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oBooleanVectorArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oBooleanVectorArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oBooleanVectorArrayExpressionNodeLeft.GenerateExpression( BooleanVectorArrayExpressionGenerator );
   a_oBooleanVectorArrayExpressionNodeRight.GenerateExpression( BooleanVectorArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oBooleanVectorArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oBooleanVectorArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateIntegerExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerExpressionNode a_oIntegerExpressionNodeLeft = new IntegerExpressionNode;
   a_oIntegerExpressionNodeLeft.Name = "Input A";
   a_oIntegerExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oIntegerExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerExpressionNode a_oIntegerExpressionNodeRight = new IntegerExpressionNode;
   a_oIntegerExpressionNodeRight.Name = "Input B";
   a_oIntegerExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oIntegerExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oIntegerExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oIntegerExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oIntegerExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oIntegerExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oIntegerExpressionNodeLeft.GenerateExpression( IntegerExpressionGenerator );
   a_oIntegerExpressionNodeRight.GenerateExpression( IntegerExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oIntegerExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oIntegerExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateIntegerArrayExpressionNodeAssignment( int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerArrayExpressionNode a_oIntegerArrayExpressionNodeLeft = new IntegerArrayExpressionNode;
   a_oIntegerArrayExpressionNodeLeft.Name = "Input A";
   a_oIntegerArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oIntegerArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oIntegerArrayExpressionNodeLeft.Count = p_nArrayDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerArrayExpressionNode a_oIntegerArrayExpressionNodeRight = new IntegerArrayExpressionNode;
   a_oIntegerArrayExpressionNodeRight.Name = "Input B";
   a_oIntegerArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oIntegerArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oIntegerArrayExpressionNodeRight.Count = p_nArrayDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oIntegerArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oIntegerArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oIntegerArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oIntegerArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oIntegerArrayExpressionNodeLeft.GenerateExpression( IntegerArrayExpressionGenerator );
   a_oIntegerArrayExpressionNodeRight.GenerateExpression( IntegerArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oIntegerArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oIntegerArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateIntegerVectorExpressionNodeAssignment( int p_nDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerVectorExpressionNode a_oIntegerVectorExpressionNodeLeft = new IntegerVectorExpressionNode;
   a_oIntegerVectorExpressionNodeLeft.Name = "Input A";
   a_oIntegerVectorExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oIntegerVectorExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oIntegerVectorExpressionNodeLeft.Dimension = p_nDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerVectorExpressionNode a_oIntegerVectorExpressionNodeRight = new IntegerVectorExpressionNode;
   a_oIntegerVectorExpressionNodeRight.Name = "Input B";
   a_oIntegerVectorExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oIntegerVectorExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oIntegerVectorExpressionNodeRight.Dimension = p_nDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oIntegerVectorExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oIntegerVectorExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oIntegerVectorExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oIntegerVectorExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oIntegerVectorExpressionNodeLeft.GenerateExpression( IntegerVectorExpressionGenerator );
   a_oIntegerVectorExpressionNodeRight.GenerateExpression( IntegerVectorExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oIntegerVectorExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oIntegerVectorExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateIntegerVectorArrayExpressionNodeAssignment(int p_nVectorDimension, int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerVectorArrayExpressionNode a_oIntegerVectorArrayExpressionNodeLeft = new IntegerVectorArrayExpressionNode;
   a_oIntegerVectorArrayExpressionNodeLeft.Name = "Input A";
   a_oIntegerVectorArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oIntegerVectorArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oIntegerVectorArrayExpressionNodeLeft.Count = p_nArrayDimension;
   a_oIntegerVectorArrayExpressionNodeLeft.Dimension = p_nVectorDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   IntegerVectorArrayExpressionNode a_oIntegerVectorArrayExpressionNodeRight = new IntegerVectorArrayExpressionNode;
   a_oIntegerVectorArrayExpressionNodeRight.Name = "Input B";
   a_oIntegerVectorArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oIntegerVectorArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oIntegerVectorArrayExpressionNodeRight.Count = p_nArrayDimension;
   a_oIntegerVectorArrayExpressionNodeRight.Dimension = p_nVectorDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oIntegerVectorArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oIntegerVectorArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oIntegerVectorArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oIntegerVectorArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oIntegerVectorArrayExpressionNodeLeft.GenerateExpression( IntegerVectorArrayExpressionGenerator );
   a_oIntegerVectorArrayExpressionNodeRight.GenerateExpression( IntegerVectorArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oIntegerVectorArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oIntegerVectorArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateUnsignedIntegerExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerExpressionNode a_oUnsignedIntegerExpressionNodeLeft = new UnsignedIntegerExpressionNode;
   a_oUnsignedIntegerExpressionNodeLeft.Name = "Input A";
   a_oUnsignedIntegerExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oUnsignedIntegerExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerExpressionNode a_oUnsignedIntegerExpressionNodeRight = new UnsignedIntegerExpressionNode;
   a_oUnsignedIntegerExpressionNodeRight.Name = "Input B";
   a_oUnsignedIntegerExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oUnsignedIntegerExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oUnsignedIntegerExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oUnsignedIntegerExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oUnsignedIntegerExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oUnsignedIntegerExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oUnsignedIntegerExpressionNodeLeft.GenerateExpression( UnsignedIntegerExpressionGenerator );
   a_oUnsignedIntegerExpressionNodeRight.GenerateExpression( UnsignedIntegerExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oUnsignedIntegerExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oUnsignedIntegerExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateUnsignedIntegerVectorExpressionNodeAssignment( int p_nDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerVectorExpressionNode a_oUnsignedIntegerVectorExpressionNodeLeft = new UnsignedIntegerVectorExpressionNode;
   a_oUnsignedIntegerVectorExpressionNodeLeft.Name = "Input A";
   a_oUnsignedIntegerVectorExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oUnsignedIntegerVectorExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerVectorExpressionNodeLeft.Dimension = p_nDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerVectorExpressionNode a_oUnsignedIntegerVectorExpressionNodeRight = new UnsignedIntegerVectorExpressionNode;
   a_oUnsignedIntegerVectorExpressionNodeRight.Name = "Input B";
   a_oUnsignedIntegerVectorExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oUnsignedIntegerVectorExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerVectorExpressionNodeRight.Dimension = p_nDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oUnsignedIntegerVectorExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oUnsignedIntegerVectorExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oUnsignedIntegerVectorExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oUnsignedIntegerVectorExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oUnsignedIntegerVectorExpressionNodeLeft.GenerateExpression( UnsignedIntegerVectorExpressionGenerator );
   a_oUnsignedIntegerVectorExpressionNodeRight.GenerateExpression( UnsignedIntegerVectorExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oUnsignedIntegerVectorExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oUnsignedIntegerVectorExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateUnsignedIntegerArrayExpressionNodeAssignment( int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerArrayExpressionNode a_oUnsignedIntegerArrayExpressionNodeLeft = new UnsignedIntegerArrayExpressionNode;
   a_oUnsignedIntegerArrayExpressionNodeLeft.Name = "Input A";
   a_oUnsignedIntegerArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oUnsignedIntegerArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerArrayExpressionNodeLeft.Count = p_nArrayDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerArrayExpressionNode a_oUnsignedIntegerArrayExpressionNodeRight = new UnsignedIntegerArrayExpressionNode;
   a_oUnsignedIntegerArrayExpressionNodeRight.Name = "Input B";
   a_oUnsignedIntegerArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oUnsignedIntegerArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerArrayExpressionNodeRight.Count = p_nArrayDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oUnsignedIntegerArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oUnsignedIntegerArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oUnsignedIntegerArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oUnsignedIntegerArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oUnsignedIntegerArrayExpressionNodeLeft.GenerateExpression( UnsignedIntegerArrayExpressionGenerator );
   a_oUnsignedIntegerArrayExpressionNodeRight.GenerateExpression( UnsignedIntegerArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oUnsignedIntegerArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oUnsignedIntegerArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateUnsignedIntegerVectorArrayExpressionNodeAssignment(int p_nVectorDimension, int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerVectorArrayExpressionNode a_oUnsignedIntegerVectorArrayExpressionNodeLeft = new UnsignedIntegerVectorArrayExpressionNode;
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.Name = "Input A";
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.Count = p_nArrayDimension;
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.Dimension = p_nVectorDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   UnsignedIntegerVectorArrayExpressionNode a_oUnsignedIntegerVectorArrayExpressionNodeRight = new UnsignedIntegerVectorArrayExpressionNode;
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.Name = "Input B";
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.Count = p_nArrayDimension;
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.Dimension = p_nVectorDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oUnsignedIntegerVectorArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oUnsignedIntegerVectorArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oUnsignedIntegerVectorArrayExpressionNodeLeft.GenerateExpression( UnsignedIntegerVectorArrayExpressionGenerator );
   a_oUnsignedIntegerVectorArrayExpressionNodeRight.GenerateExpression( UnsignedIntegerVectorArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oUnsignedIntegerVectorArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oUnsignedIntegerVectorArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateFloatExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   FloatExpressionNode a_oFloatExpressionNodeLeft = new FloatExpressionNode;
   a_oFloatExpressionNodeLeft.Name = "Input A";
   a_oFloatExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oFloatExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   FloatExpressionNode a_oFloatExpressionNodeRight = new FloatExpressionNode;
   a_oFloatExpressionNodeRight.Name = "Input B";
   a_oFloatExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oFloatExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oFloatExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oFloatExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oFloatExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oFloatExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oFloatExpressionNodeLeft.GenerateExpression( FloatExpressionGenerator );
   a_oFloatExpressionNodeRight.GenerateExpression( FloatExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oFloatExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oFloatExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateFloatArrayExpressionNodeAssignment( int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   FloatArrayExpressionNode a_oFloatArrayExpressionNodeLeft = new FloatArrayExpressionNode;
   a_oFloatArrayExpressionNodeLeft.Name = "Input A";
   a_oFloatArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oFloatArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oFloatArrayExpressionNodeLeft.Count = p_nArrayDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   FloatArrayExpressionNode a_oFloatArrayExpressionNodeRight = new FloatArrayExpressionNode;
   a_oFloatArrayExpressionNodeRight.Name = "Input B";
   a_oFloatArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oFloatArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oFloatArrayExpressionNodeRight.Count = p_nArrayDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oFloatArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oFloatArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oFloatArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oFloatArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oFloatArrayExpressionNodeLeft.GenerateExpression( FloatArrayExpressionGenerator );
   a_oFloatArrayExpressionNodeRight.GenerateExpression( FloatArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oFloatArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oFloatArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateVectorExpressionNodeAssignment( int p_nDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   VectorExpressionNode a_oVectorExpressionNodeLeft = new VectorExpressionNode;
   a_oVectorExpressionNodeLeft.Name = "Input A";
   a_oVectorExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oVectorExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oVectorExpressionNodeLeft.Dimension = p_nDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   VectorExpressionNode a_oVectorExpressionNodeRight = new VectorExpressionNode;
   a_oVectorExpressionNodeRight.Name = "Input B";
   a_oVectorExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oVectorExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oVectorExpressionNodeRight.Dimension = p_nDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oVectorExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oVectorExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oVectorExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oVectorExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oVectorExpressionNodeLeft.GenerateExpression( VectorExpressionGenerator );
   a_oVectorExpressionNodeRight.GenerateExpression( VectorExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oVectorExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oVectorExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateVectorArrayExpressionNodeAssignment(int p_nVectorDimension, int p_nArrayDimension )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   VectorArrayExpressionNode a_oVectorArrayExpressionNodeLeft = new VectorArrayExpressionNode;
   a_oVectorArrayExpressionNodeLeft.Name = "Input A";
   a_oVectorArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oVectorArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oVectorArrayExpressionNodeLeft.Count = p_nArrayDimension;
   a_oVectorArrayExpressionNodeLeft.Dimension = p_nVectorDimension;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   VectorArrayExpressionNode a_oVectorArrayExpressionNodeRight = new VectorArrayExpressionNode;
   a_oVectorArrayExpressionNodeRight.Name = "Input B";
   a_oVectorArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oVectorArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oVectorArrayExpressionNodeRight.Count = p_nArrayDimension;
   a_oVectorArrayExpressionNodeRight.Dimension = p_nVectorDimension;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oVectorArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oVectorArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oVectorArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oVectorArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oVectorArrayExpressionNodeLeft.GenerateExpression( VectorArrayExpressionGenerator );
   a_oVectorArrayExpressionNodeRight.GenerateExpression( VectorArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oVectorArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oVectorArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateMatrixExpressionNodeAssignment( int p_nCols, int p_nRows )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   MatrixExpressionNode a_oMatrixExpressionNodeLeft = new MatrixExpressionNode;
   a_oMatrixExpressionNodeLeft.Name = "Input A";
   a_oMatrixExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oMatrixExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oMatrixExpressionNodeLeft.Cols = p_nCols;
   a_oMatrixExpressionNodeLeft.Rows = p_nRows;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   MatrixExpressionNode a_oMatrixExpressionNodeRight = new MatrixExpressionNode;
   a_oMatrixExpressionNodeRight.Name = "Input B";
   a_oMatrixExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oMatrixExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oMatrixExpressionNodeRight.Cols = p_nCols;
   a_oMatrixExpressionNodeRight.Rows = p_nRows;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oMatrixExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oMatrixExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oMatrixExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oMatrixExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oMatrixExpressionNodeLeft.GenerateExpression( MatrixExpressionGenerator );
   a_oMatrixExpressionNodeRight.GenerateExpression( MatrixExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oMatrixExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oMatrixExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateMatrixArrayExpressionNodeAssignment( int p_nCols, int p_nRows, int p_nArrayDimension, string p_sName )
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = p_sName;
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   MatrixArrayExpressionNode a_oMatrixArrayExpressionNodeLeft = new MatrixArrayExpressionNode;
   a_oMatrixArrayExpressionNodeLeft.Name = "Input A";
   a_oMatrixArrayExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oMatrixArrayExpressionNodeLeft.NodeSelector.SetContainer( Model );
   a_oMatrixArrayExpressionNodeLeft.Count = p_nArrayDimension;
   a_oMatrixArrayExpressionNodeLeft.Cols = p_nCols;
   a_oMatrixArrayExpressionNodeLeft.Rows = p_nRows;
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   MatrixArrayExpressionNode a_oMatrixArrayExpressionNodeRight = new MatrixArrayExpressionNode;
   a_oMatrixArrayExpressionNodeRight.Name = "Input B";
   a_oMatrixArrayExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oMatrixArrayExpressionNodeRight.NodeSelector.SetContainer( Model );
   a_oMatrixArrayExpressionNodeRight.Count = p_nArrayDimension;
   a_oMatrixArrayExpressionNodeRight.Cols = p_nCols;
   a_oMatrixArrayExpressionNodeRight.Rows = p_nRows;
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oMatrixArrayExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oMatrixArrayExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oMatrixArrayExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oMatrixArrayExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oMatrixArrayExpressionNodeLeft.GenerateExpression( MatrixArrayExpressionGenerator );
   a_oMatrixArrayExpressionNodeRight.GenerateExpression( MatrixArrayExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oMatrixArrayExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oMatrixArrayExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateStructExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   StructExpressionNode a_oStructExpressionNodeLeft = new StructExpressionNode;
   a_oStructExpressionNodeLeft.Name = "Input A";
   a_oStructExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oStructExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   StructExpressionNode a_oStructExpressionNodeRight = new StructExpressionNode;
   a_oStructExpressionNodeRight.Name = "Input B";
   a_oStructExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oStructExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oStructExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oStructExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oStructExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oStructExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oStructExpressionNodeLeft.GenerateExpression( StructExpressionGenerator );
   a_oStructExpressionNodeRight.GenerateExpression( StructExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oStructExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oStructExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void CreateSamplerExpressionNodeAssignment()
{
   // First selected node index.
   Group a_oSelectedGroup = (Group)Model.GetFirstSelectedNode().GetNode();
   // Create a new ExpressionNode to contain the expression elements.
   ExpressionNode a_oExpressionNode = new ExpressionNode;
   a_oExpressionNode.Name = "Assignment Expression";
   // Create a new left side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   SamplerExpressionNode a_oSamplerExpressionNodeLeft = new SamplerExpressionNode;
   a_oSamplerExpressionNodeLeft.Name = "Input A";
   a_oSamplerExpressionNodeLeft.ExpressionSide = Enum.ExpressionSide_Left();
   a_oSamplerExpressionNodeLeft.NodeSelector.SetContainer( Model );
   // Create a new BinaryOperatorNode for assignment.
   BinaryOperatorNode a_oBinaryOperatorNode = new BinaryOperatorNode;
   a_oBinaryOperatorNode.Name = "Assign";
   // Create a new right side expression. Make sure we set its ExpressionSide flag, as we can only do this once.
   SamplerExpressionNode a_oSamplerExpressionNodeRight = new SamplerExpressionNode;
   a_oSamplerExpressionNodeRight.Name = "Input B";
   a_oSamplerExpressionNodeRight.ExpressionSide = Enum.ExpressionSide_Right();
   a_oSamplerExpressionNodeRight.NodeSelector.SetContainer( Model );
   // Wire the expression correctly. Connect each expression to the operator and connect the operator to each expression.
   a_oSamplerExpressionNodeLeft.OperatorDataSource = a_oBinaryOperatorNode;
   a_oSamplerExpressionNodeRight.OperatorDataSource = a_oBinaryOperatorNode;
   a_oBinaryOperatorNode.LeftDataSource = a_oSamplerExpressionNodeLeft;
   a_oBinaryOperatorNode.RightDataSource = a_oSamplerExpressionNodeRight;
   // Generate the left/right side expressions.
   a_oSamplerExpressionNodeLeft.GenerateExpression( SamplerExpressionGenerator );
   a_oSamplerExpressionNodeRight.GenerateExpression( SamplerExpressionGenerator );
   // Parent the new nodes in correct order and add the ExpressionNode to the document.
   Model.AddNode( a_oSamplerExpressionNodeLeft, a_oExpressionNode, -1 );
   Model.AddNode( a_oBinaryOperatorNode, a_oExpressionNode, -1 );
   Model.AddNode( a_oSamplerExpressionNodeRight, a_oExpressionNode, -1 );
   Model.AddNode( a_oExpressionNode, a_oSelectedGroup, -1 );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureBooleanArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   BooleanArrayExpressionNode a_oBooleanArrayExpressionNode =
      (BooleanArrayExpressionNode)p_oNotEditedExpression;
   BooleanArrayExpressionNode a_oBooleanArrayExpressionNodeEdited =
      (BooleanArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   if( p_oIsVariable.IsDerived( BooleanArrayNode ) )
   {
      int a_nDimension;
      BooleanArrayNode a_oBooleanArrayNode = (BooleanArrayNode)p_oIsVariable;
      a_nDimension = a_oBooleanArrayNode.Count;
      if( a_oBooleanArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oBooleanArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( BooleanArrayExpressionNode ) )
         {
            BooleanArrayExpressionNode a_oOpposite = (BooleanArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( BooleanArrayNode ) )
            {
               a_nDimension = a_oBooleanArrayNode.Count;
               a_oOpposite.Count = a_oBooleanArrayNode.Count;
               BooleanArrayExpressionNode a_oEdit = (BooleanArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oBooleanArrayNode.Count;
               a_oEdit.GenerateExpression( BooleanArrayExpressionGenerator );
            }
         }
         a_oBooleanArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oBooleanArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oBooleanArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oBooleanArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oBooleanArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nDimension == a_oBooleanArrayExpressionNode.Count || a_oBooleanArrayExpressionNode.Count == 0 )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oBooleanArrayNode.Variable )
         {
            a_oBooleanArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oBooleanArrayExpressionNodeEdited.GenerateExpression( BooleanArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureBooleanVectorArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   BooleanVectorArrayExpressionNode a_oBooleanVectorArrayExpressionNode =
      (BooleanVectorArrayExpressionNode)p_oNotEditedExpression;
   BooleanVectorArrayExpressionNode a_oBooleanVectorArrayExpressionNodeEdited =
      (BooleanVectorArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   // Make sure we clear member selection.
   a_oBooleanVectorArrayExpressionNodeEdited.ClearMemberSelection();
   if( p_oIsVariable.IsDerived( BooleanVectorArrayNode ) )
   {
      int a_nDimension;
      int a_nVectorDimension;
      BooleanVectorArrayNode a_oBooleanVectorArrayNode = (BooleanVectorArrayNode)p_oIsVariable;
      a_nVectorDimension = a_oBooleanVectorArrayNode.VectorDimension;
      if( a_oBooleanVectorArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oBooleanVectorArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( BooleanVectorArrayExpressionNode ) )
         {
            BooleanVectorArrayExpressionNode a_oOpposite = (BooleanVectorArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( BooleanVectorArrayNode ) )
            {
               a_nDimension = a_oBooleanVectorArrayNode.Count;
               a_oOpposite.Count = a_oBooleanVectorArrayNode.Count;
               BooleanVectorArrayExpressionNode a_oEdit = (BooleanVectorArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oBooleanVectorArrayNode.Count;
               a_oEdit.GenerateExpression( BooleanVectorArrayExpressionGenerator );
            }
         }
         a_oBooleanVectorArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oBooleanVectorArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oBooleanVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oBooleanVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oBooleanVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nVectorDimension == a_oBooleanVectorArrayExpressionNode.Dimension )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oBooleanVectorArrayNode.Variable )
         {
            a_oBooleanVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oBooleanVectorArrayExpressionNodeEdited.GenerateExpression( BooleanVectorArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureIntegerArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   IntegerArrayExpressionNode a_oIntegerArrayExpressionNode =
      (IntegerArrayExpressionNode)p_oNotEditedExpression;
   IntegerArrayExpressionNode a_oIntegerArrayExpressionNodeEdited =
      (IntegerArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   if( p_oIsVariable.IsDerived( IntegerArrayNode ) )
   {
      int a_nDimension;
      IntegerArrayNode a_oIntegerArrayNode = (IntegerArrayNode)p_oIsVariable;
      a_nDimension = a_oIntegerArrayNode.Count;
      if( a_oIntegerArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oIntegerArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( IntegerArrayExpressionNode ) )
         {
            IntegerArrayExpressionNode a_oOpposite = (IntegerArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( IntegerArrayNode ) )
            {
               a_nDimension = a_oIntegerArrayNode.Count;
               a_oOpposite.Count = a_oIntegerArrayNode.Count;
               IntegerArrayExpressionNode a_oEdit = (IntegerArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oIntegerArrayNode.Count;
               a_oEdit.GenerateExpression( IntegerArrayExpressionGenerator );
            }
         }
         a_oIntegerArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oIntegerArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oIntegerArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oIntegerArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oIntegerArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nDimension == a_oIntegerArrayExpressionNode.Count || a_oIntegerArrayExpressionNode.Count == 0 )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oIntegerArrayNode.Variable )
         {
            a_oIntegerArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oIntegerArrayExpressionNodeEdited.GenerateExpression( IntegerArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureIntegerVectorArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   IntegerVectorArrayExpressionNode a_oIntegerVectorArrayExpressionNode =
      (IntegerVectorArrayExpressionNode)p_oNotEditedExpression;
   IntegerVectorArrayExpressionNode a_oIntegerVectorArrayExpressionNodeEdited =
      (IntegerVectorArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   // Make sure we clear member selection.
   a_oIntegerVectorArrayExpressionNodeEdited.ClearMemberSelection();
   if( p_oIsVariable.IsDerived( IntegerVectorArrayNode ) )
   {
      int a_nDimension;
      int a_nVectorDimension;
      IntegerVectorArrayNode a_oIntegerVectorArrayNode = (IntegerVectorArrayNode)p_oIsVariable;
      a_nVectorDimension = a_oIntegerVectorArrayNode.VectorDimension;
      if( a_oIntegerVectorArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oIntegerVectorArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( IntegerVectorArrayExpressionNode ) )
         {
            IntegerVectorArrayExpressionNode a_oOpposite = (IntegerVectorArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( IntegerVectorArrayNode ) )
            {
               a_nDimension = a_oIntegerVectorArrayNode.Count;
               a_oOpposite.Count = a_oIntegerVectorArrayNode.Count;
               IntegerVectorArrayExpressionNode a_oEdit = (IntegerVectorArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oIntegerVectorArrayNode.Count;
               a_oEdit.GenerateExpression( IntegerVectorArrayExpressionGenerator );
            }
         }
         a_oIntegerVectorArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oIntegerVectorArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oIntegerVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oIntegerVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oIntegerVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nVectorDimension == a_oIntegerVectorArrayExpressionNode.Dimension )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oIntegerVectorArrayNode.Variable )
         {
            a_oIntegerVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oIntegerVectorArrayExpressionNodeEdited.GenerateExpression( IntegerVectorArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureUnsignedIntegerArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   UnsignedIntegerArrayExpressionNode a_oUnsignedIntegerArrayExpressionNode =
      (UnsignedIntegerArrayExpressionNode)p_oNotEditedExpression;
   UnsignedIntegerArrayExpressionNode a_oUnsignedIntegerArrayExpressionNodeEdited =
      (UnsignedIntegerArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   if( p_oIsVariable.IsDerived( UnsignedIntegerArrayNode ) )
   {
      int a_nDimension;
      UnsignedIntegerArrayNode a_oUnsignedIntegerArrayNode = (UnsignedIntegerArrayNode)p_oIsVariable;
      a_nDimension = a_oUnsignedIntegerArrayNode.Count;
      if( a_oUnsignedIntegerArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oUnsignedIntegerArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( UnsignedIntegerArrayExpressionNode ) )
         {
            UnsignedIntegerArrayExpressionNode a_oOpposite = (UnsignedIntegerArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( UnsignedIntegerArrayNode ) )
            {
               a_nDimension = a_oUnsignedIntegerArrayNode.Count;
               a_oOpposite.Count = a_oUnsignedIntegerArrayNode.Count;
               UnsignedIntegerArrayExpressionNode a_oEdit = (UnsignedIntegerArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oUnsignedIntegerArrayNode.Count;
               a_oEdit.GenerateExpression( UnsignedIntegerArrayExpressionGenerator );
            }
         }
         a_oUnsignedIntegerArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oUnsignedIntegerArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oUnsignedIntegerArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oUnsignedIntegerArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oUnsignedIntegerArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nDimension == a_oUnsignedIntegerArrayExpressionNode.Count || a_oUnsignedIntegerArrayExpressionNode.Count == 0 )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oUnsignedIntegerArrayNode.Variable )
         {
            a_oUnsignedIntegerArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oUnsignedIntegerArrayExpressionNodeEdited.GenerateExpression( UnsignedIntegerArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureUnsignedIntegerVectorArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   UnsignedIntegerVectorArrayExpressionNode a_oUnsignedIntegerVectorArrayExpressionNode =
      (UnsignedIntegerVectorArrayExpressionNode)p_oNotEditedExpression;
   UnsignedIntegerVectorArrayExpressionNode a_oUnsignedIntegerVectorArrayExpressionNodeEdited =
      (UnsignedIntegerVectorArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   // Make sure we clear member selection.
   a_oUnsignedIntegerVectorArrayExpressionNodeEdited.ClearMemberSelection();
   if( p_oIsVariable.IsDerived( UnsignedIntegerVectorArrayNode ) )
   {
      int a_nDimension;
      int a_nVectorDimension;
      UnsignedIntegerVectorArrayNode a_oUnsignedIntegerVectorArrayNode = (UnsignedIntegerVectorArrayNode)p_oIsVariable;
      a_nVectorDimension = a_oUnsignedIntegerVectorArrayNode.VectorDimension;
      if( a_oUnsignedIntegerVectorArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oUnsignedIntegerVectorArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( UnsignedIntegerVectorArrayExpressionNode ) )
         {
            UnsignedIntegerVectorArrayExpressionNode a_oOpposite = (UnsignedIntegerVectorArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( UnsignedIntegerVectorArrayNode ) )
            {
               a_nDimension = a_oUnsignedIntegerVectorArrayNode.Count;
               a_oOpposite.Count = a_oUnsignedIntegerVectorArrayNode.Count;
               UnsignedIntegerVectorArrayExpressionNode a_oEdit = (UnsignedIntegerVectorArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oUnsignedIntegerVectorArrayNode.Count;
               a_oEdit.GenerateExpression( UnsignedIntegerVectorArrayExpressionGenerator );
            }
         }
         a_oUnsignedIntegerVectorArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oUnsignedIntegerVectorArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oUnsignedIntegerVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oUnsignedIntegerVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oUnsignedIntegerVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nVectorDimension == a_oUnsignedIntegerVectorArrayExpressionNode.Dimension )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oUnsignedIntegerVectorArrayNode.Variable )
         {
            a_oUnsignedIntegerVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oUnsignedIntegerVectorArrayExpressionNodeEdited.GenerateExpression( UnsignedIntegerVectorArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureFloatArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   FloatArrayExpressionNode a_oFloatArrayExpressionNode =
      (FloatArrayExpressionNode)p_oNotEditedExpression;
   FloatArrayExpressionNode a_oFloatArrayExpressionNodeEdited =
      (FloatArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   if( p_oIsVariable.IsDerived( FloatArrayNode ) )
   {
      int a_nDimension;
      FloatArrayNode a_oFloatArrayNode = (FloatArrayNode)p_oIsVariable;
      a_nDimension = a_oFloatArrayNode.Count;
      if( a_oFloatArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oFloatArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( FloatArrayExpressionNode ) )
         {
            FloatArrayExpressionNode a_oOpposite = (FloatArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( FloatArrayNode ) )
            {
               a_nDimension = a_oFloatArrayNode.Count;
               a_oOpposite.Count = a_oFloatArrayNode.Count;
               FloatArrayExpressionNode a_oEdit = (FloatArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oFloatArrayNode.Count;
               a_oEdit.GenerateExpression( FloatArrayExpressionGenerator );
            }
         }
         a_oFloatArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oFloatArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oFloatArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oFloatArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oFloatArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nDimension == a_oFloatArrayExpressionNode.Count || a_oFloatArrayExpressionNode.Count == 0 )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oFloatArrayNode.Variable )
         {
            a_oFloatArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oFloatArrayExpressionNodeEdited.GenerateExpression( FloatArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureVectorArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   VectorArrayExpressionNode a_oVectorArrayExpressionNode =
      (VectorArrayExpressionNode)p_oNotEditedExpression;
   VectorArrayExpressionNode a_oVectorArrayExpressionNodeEdited =
      (VectorArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   // Make sure we clear member selection.
   a_oVectorArrayExpressionNodeEdited.ClearMemberSelection();
   if( p_oIsVariable.IsDerived( VectorArrayNode ) )
   {
      int a_nDimension;
      int a_nVectorDimension;
      VectorArrayNode a_oVectorArrayNode = (VectorArrayNode)p_oIsVariable;
      a_nVectorDimension = a_oVectorArrayNode.VectorDimension;
      if( a_oVectorArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oVectorArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( VectorArrayExpressionNode ) )
         {
            VectorArrayExpressionNode a_oOpposite = (VectorArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( VectorArrayNode ) )
            {
               a_nDimension = a_oVectorArrayNode.Count;
               a_oOpposite.Count = a_oVectorArrayNode.Count;
               VectorArrayExpressionNode a_oEdit = (VectorArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oVectorArrayNode.Count;
               a_oEdit.GenerateExpression( VectorArrayExpressionGenerator );
            }
         }
         a_oVectorArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oVectorArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oVectorArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nVectorDimension == a_oVectorArrayExpressionNode.Dimension )
         {
            a_nArrayInfo = 0;
         }
         if( a_sVariableName == a_oVectorArrayNode.Variable )
         {
            a_oVectorArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oVectorArrayExpressionNodeEdited.GenerateExpression( VectorArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureMatrixArrayExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oNotEditedExpression, Node p_oIsVariable )
{
   MatrixArrayExpressionNode a_oMatrixArrayExpressionNode =
      (MatrixArrayExpressionNode)p_oNotEditedExpression;
   MatrixArrayExpressionNode a_oMatrixArrayExpressionNodeEdited =
      (MatrixArrayExpressionNode)p_oVariableExpressionNode;
   // If we're setting a left side for the first time, we need to
   // make sure that we change the right side dimension to match.
   // Conversely, do not ever change the left side as a result of
   // changes to the right side.
   // Make sure we clear member selection.

   if( p_oIsVariable.IsDerived( MatrixArrayNode ) )
   {
      int a_nDimension;
      MatrixArrayNode a_oMatrixArrayNode = (MatrixArrayNode)p_oIsVariable;
      if( a_oMatrixArrayExpressionNode.IsLeftOperand() )
      {
         Node a_oIsOpposite = (Node)a_oMatrixArrayExpressionNode.GetOppositeExpression();
         if( a_oIsOpposite && a_oIsOpposite.IsDerived( MatrixArrayExpressionNode ) )
         {
            MatrixArrayExpressionNode a_oOpposite = (MatrixArrayExpressionNode)a_oIsOpposite;
            if( p_oIsVariable && p_oIsVariable.IsDerived( MatrixArrayNode ) )
            {
               a_nDimension = a_oMatrixArrayNode.Count;
               a_oOpposite.Count = a_oMatrixArrayNode.Count;
               MatrixArrayExpressionNode a_oEdit = (MatrixArrayExpressionNode)Model.EditNode( a_oOpposite );
               a_oEdit.Count = a_oMatrixArrayNode.Count;
               a_oEdit.GenerateExpression( MatrixArrayExpressionGenerator );
            }
         }
         a_oMatrixArrayExpressionNodeEdited.Count = a_nDimension;
      }
      else
      {
         a_nDimension = a_oMatrixArrayNode.Count;
      }
      for( int a_nInfoRe = 0; a_nInfoRe < a_oMatrixArrayExpressionNodeEdited.CodeObjectNodeNames.GetCount(); ++a_nInfoRe )
      {
         string a_sVariableName = a_oMatrixArrayExpressionNodeEdited.CodeObjectNodeNames.GetAt( a_nInfoRe );
         int a_nArrayInfo = a_oMatrixArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ];
         if( a_nDimension == a_oMatrixArrayExpressionNode.Count || a_oMatrixArrayExpressionNode.Count == 0 )
         {
            if(   a_oMatrixArrayExpressionNode.Rows == a_oMatrixArrayNode.Rows &&
                  a_oMatrixArrayExpressionNode.Cols == a_oMatrixArrayNode.Cols )
            {
               a_nArrayInfo = 0;
            }
         }
         if( a_sVariableName == a_oMatrixArrayNode.Variable )
         {
            a_oMatrixArrayExpressionNodeEdited.CodeObjectDimensions.Objects[ a_nInfoRe ] = a_nArrayInfo;
         }
         // DEBUG
         //Console.Out( a_sVariableName + " " + a_nArrayInfo );
      }
   }
   a_oMatrixArrayExpressionNodeEdited.GenerateExpression( MatrixArrayExpressionGenerator );
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool GenerateExpressionT( VariableExpressionNode p_oVariableExpressionNode )
{
   if( p_oVariableExpressionNode.IsDerived( BooleanExpressionNode ) )
   {
      BooleanExpressionNode a_oBooleanExpressionNode =
         (BooleanExpressionNode)p_oVariableExpressionNode;
      a_oBooleanExpressionNode.GenerateExpression( BooleanExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( BooleanArrayExpressionNode ) )
   {
      BooleanArrayExpressionNode a_oBooleanArrayExpressionNode =
         (BooleanArrayExpressionNode)p_oVariableExpressionNode;
      a_oBooleanArrayExpressionNode.GenerateExpression( BooleanArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( BooleanVectorExpressionNode ) )
   {
      BooleanVectorExpressionNode a_oBooleanVectorExpressionNode =
         (BooleanVectorExpressionNode)p_oVariableExpressionNode;
      a_oBooleanVectorExpressionNode.GenerateExpression( BooleanVectorExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( BooleanVectorArrayExpressionNode ) )
   {
      BooleanVectorArrayExpressionNode a_oBooleanVectorArrayExpressionNode =
         (BooleanVectorArrayExpressionNode)p_oVariableExpressionNode;
      a_oBooleanVectorArrayExpressionNode.GenerateExpression( BooleanVectorArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( IntegerExpressionNode ) )
   {
      IntegerExpressionNode a_oIntegerExpressionNode =
         (IntegerExpressionNode)p_oVariableExpressionNode;
      a_oIntegerExpressionNode.GenerateExpression( IntegerExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( IntegerArrayExpressionNode ) )
   {
      IntegerArrayExpressionNode a_oIntegerArrayExpressionNode =
         (IntegerArrayExpressionNode)p_oVariableExpressionNode;
      a_oIntegerArrayExpressionNode.GenerateExpression( IntegerArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( IntegerVectorExpressionNode ) )
   {
      IntegerVectorExpressionNode a_oIntegerVectorExpressionNode =
         (IntegerVectorExpressionNode)p_oVariableExpressionNode;
      a_oIntegerVectorExpressionNode.GenerateExpression( IntegerVectorExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( IntegerVectorArrayExpressionNode ) )
   {
      IntegerVectorArrayExpressionNode a_oIntegerVectorArrayExpressionNode =
         (IntegerVectorArrayExpressionNode)p_oVariableExpressionNode;
      a_oIntegerVectorArrayExpressionNode.GenerateExpression( IntegerVectorArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( UnsignedIntegerExpressionNode ) )
   {
      UnsignedIntegerExpressionNode a_oUnsignedIntegerExpressionNode =
         (UnsignedIntegerExpressionNode)p_oVariableExpressionNode;
      a_oUnsignedIntegerExpressionNode.GenerateExpression( UnsignedIntegerExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( UnsignedIntegerVectorExpressionNode ) )
   {
      UnsignedIntegerVectorExpressionNode a_oUnsignedIntegerVectorExpressionNode =
         (UnsignedIntegerVectorExpressionNode)p_oVariableExpressionNode;
      a_oUnsignedIntegerVectorExpressionNode.GenerateExpression( UnsignedIntegerVectorExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( UnsignedIntegerArrayExpressionNode ) )
   {
      UnsignedIntegerArrayExpressionNode a_oUnsignedIntegerArrayExpressionNode =
         (UnsignedIntegerArrayExpressionNode)p_oVariableExpressionNode;
      a_oUnsignedIntegerArrayExpressionNode.GenerateExpression( UnsignedIntegerArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( UnsignedIntegerVectorArrayExpressionNode ) )
   {
      UnsignedIntegerVectorArrayExpressionNode a_oUnsignedIntegerVectorArrayExpressionNode =
         (UnsignedIntegerVectorArrayExpressionNode)p_oVariableExpressionNode;
      a_oUnsignedIntegerVectorArrayExpressionNode.GenerateExpression( UnsignedIntegerVectorArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( FloatExpressionNode ) )
   {
      FloatExpressionNode a_oFloatExpressionNode =
         (FloatExpressionNode)p_oVariableExpressionNode;
      a_oFloatExpressionNode.GenerateExpression( FloatExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( FloatArrayExpressionNode ) )
   {
      FloatArrayExpressionNode a_oFloatArrayExpressionNode =
         (FloatArrayExpressionNode)p_oVariableExpressionNode;
      a_oFloatArrayExpressionNode.GenerateExpression( FloatArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( VectorExpressionNode ) )
   {
      VectorExpressionNode a_oVectorExpressionNode =
         (VectorExpressionNode)p_oVariableExpressionNode;
      a_oVectorExpressionNode.GenerateExpression( VectorExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( VectorArrayExpressionNode ) )
   {
      VectorArrayExpressionNode a_oVectorArrayExpressionNode =
         (VectorArrayExpressionNode)p_oVariableExpressionNode;
      a_oVectorArrayExpressionNode.GenerateExpression( VectorArrayExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( MatrixExpressionNode ) )
   {
      MatrixExpressionNode a_oMatrixExpressionNode =
         (MatrixExpressionNode)p_oVariableExpressionNode;
      a_oMatrixExpressionNode.GenerateExpression( MatrixExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( StructExpressionNode ) )
   {
      StructExpressionNode a_oStructExpressionNode =
         (StructExpressionNode)p_oVariableExpressionNode;
      a_oStructExpressionNode.GenerateExpression( StructExpressionGenerator );
      return true;
   }
   else
   if( p_oVariableExpressionNode.IsDerived( SamplerExpressionNode ) )
   {
      SamplerExpressionNode a_oSamplerExpressionNode =
         (SamplerExpressionNode)p_oVariableExpressionNode;
      a_oSamplerExpressionNode.GenerateExpression( SamplerExpressionGenerator );
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureBooleanVectorExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oVariableNode )
{
   BooleanVectorExpressionNode a_oBooleanVectorExpressionNode = (BooleanVectorExpressionNode)p_oVariableExpressionNode;
   int a_nVariableDimension = a_oBooleanVectorExpressionNode.GetVariableDimension();
   if( p_oVariableNode.IsDerived( MatrixNode ) )
   {
      MatrixNode a_oMatrixNode = (MatrixNode)p_oVariableNode;
      a_nVariableDimension = a_oMatrixNode.Rows;
   }
   if( a_oBooleanVectorExpressionNode.IsLeftOperand() || a_oBooleanVectorExpressionNode.IsRightOperand() )
   {
      if( a_nVariableDimension < a_oBooleanVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oBooleanVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension == a_oBooleanVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oBooleanVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension > a_oBooleanVectorExpressionNode.Dimension )
      {
         // Set member selection to expression dimension.
         a_oBooleanVectorExpressionNode.InitializeMemberSelection( a_oBooleanVectorExpressionNode.Dimension );
      }
   }
   // If dimension hasn't been set.
   if( a_oBooleanVectorExpressionNode.Dimension == -1 )
   {
      a_oBooleanVectorExpressionNode.Dimension = a_oBooleanVectorExpressionNode.GetVariableDimension();
   }
   a_oBooleanVectorExpressionNode.GenerateExpression( BooleanVectorExpressionGenerator );
   a_oBooleanVectorExpressionNode.SelectedMatrixCol = 0;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureIntegerVectorExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oVariableNode )
{
   IntegerVectorExpressionNode a_oIntegerVectorExpressionNode = (IntegerVectorExpressionNode)p_oVariableExpressionNode;
   int a_nVariableDimension = a_oIntegerVectorExpressionNode.GetVariableDimension();
   if( p_oVariableNode.IsDerived( MatrixNode ) )
   {
      MatrixNode a_oMatrixNode = (MatrixNode)p_oVariableNode;
      a_nVariableDimension = a_oMatrixNode.Rows;
   }
   if( a_oIntegerVectorExpressionNode.IsLeftOperand() || a_oIntegerVectorExpressionNode.IsRightOperand() )
   {
      if( a_nVariableDimension < a_oIntegerVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oIntegerVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension == a_oIntegerVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oIntegerVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension > a_oIntegerVectorExpressionNode.Dimension )
      {
         // Set member selection to expression dimension.
         a_oIntegerVectorExpressionNode.InitializeMemberSelection( a_oIntegerVectorExpressionNode.Dimension );
      }
   }
   // If dimension hasn't been set.
   if( a_oIntegerVectorExpressionNode.Dimension == -1 )
   {
      a_oIntegerVectorExpressionNode.Dimension = a_oIntegerVectorExpressionNode.GetVariableDimension();
   }
   a_oIntegerVectorExpressionNode.GenerateExpression( IntegerVectorExpressionGenerator );
   a_oIntegerVectorExpressionNode.SelectedMatrixCol = 0;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureUnsignedIntegerVectorExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oVariableNode )
{
   UnsignedIntegerVectorExpressionNode a_oUnsignedIntegerVectorExpressionNode = (UnsignedIntegerVectorExpressionNode)p_oVariableExpressionNode;
   int a_nVariableDimension = a_oUnsignedIntegerVectorExpressionNode.GetVariableDimension();
   if( p_oVariableNode.IsDerived( MatrixNode ) )
   {
      MatrixNode a_oMatrixNode = (MatrixNode)p_oVariableNode;
      a_nVariableDimension = a_oMatrixNode.Rows;
   }
   if( a_oUnsignedIntegerVectorExpressionNode.IsLeftOperand() || a_oUnsignedIntegerVectorExpressionNode.IsRightOperand() )
   {
      if( a_nVariableDimension < a_oUnsignedIntegerVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oUnsignedIntegerVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension == a_oUnsignedIntegerVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oUnsignedIntegerVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension > a_oUnsignedIntegerVectorExpressionNode.Dimension )
      {
         // Set member selection to expression dimension.
         a_oUnsignedIntegerVectorExpressionNode.InitializeMemberSelection( a_oUnsignedIntegerVectorExpressionNode.Dimension );
      }
   }
   // If dimension hasn't been set.
   if( a_oUnsignedIntegerVectorExpressionNode.Dimension == -1 )
   {
      a_oUnsignedIntegerVectorExpressionNode.Dimension = a_oUnsignedIntegerVectorExpressionNode.GetVariableDimension();
   }
   a_oUnsignedIntegerVectorExpressionNode.GenerateExpression( UnsignedIntegerVectorExpressionGenerator );
   a_oUnsignedIntegerVectorExpressionNode.SelectedMatrixCol = 0;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function void ConfigureVectorExpressionNode( VariableExpressionNode p_oVariableExpressionNode, Node p_oVariableNode )
{
   VectorExpressionNode a_oVectorExpressionNode = (VectorExpressionNode)p_oVariableExpressionNode;
   int a_nVariableDimension = a_oVectorExpressionNode.GetVariableDimension();
   if( p_oVariableNode.IsDerived( MatrixNode ) )
   {
      MatrixNode a_oMatrixNode = (MatrixNode)p_oVariableNode;
      a_nVariableDimension = a_oMatrixNode.Rows;
   }
   if( a_oVectorExpressionNode.IsLeftOperand() || a_oVectorExpressionNode.IsRightOperand() )
   {
      if( a_nVariableDimension < a_oVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension == a_oVectorExpressionNode.Dimension )
      {
         // Make sure we clear member selection.
         a_oVectorExpressionNode.ClearMemberSelection();
      }
      else
      if( a_nVariableDimension > a_oVectorExpressionNode.Dimension )
      {
         // Set member selection to expression dimension.
         a_oVectorExpressionNode.InitializeMemberSelection( a_oVectorExpressionNode.Dimension );
      }
   }
   // If dimension hasn't been set.
   if( a_oVectorExpressionNode.Dimension == -1 )
   {
      a_oVectorExpressionNode.Dimension = a_oVectorExpressionNode.GetVariableDimension();
   }
   a_oVectorExpressionNode.GenerateExpression( VectorExpressionGenerator );
   a_oVectorExpressionNode.SelectedMatrixCol = 0;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateBooleanArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   BooleanArrayExpressionNode a_oExpressionSelected =
      (BooleanArrayExpressionNode)p_oSelNode;
   BooleanArrayNode a_oVariable =
      (BooleanArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateBooleanVectorArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   BooleanVectorArrayExpressionNode a_oExpressionSelected =
      (BooleanVectorArrayExpressionNode)p_oSelNode;
   BooleanVectorArrayNode a_oVariable =
      (BooleanVectorArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateIntegerArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   IntegerArrayExpressionNode a_oExpressionSelected =
      (IntegerArrayExpressionNode)p_oSelNode;
   IntegerArrayNode a_oVariable =
      (IntegerArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateUnsignedIntegerArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   UnsignedIntegerArrayExpressionNode a_oExpressionSelected =
      (UnsignedIntegerArrayExpressionNode)p_oSelNode;
   UnsignedIntegerArrayNode a_oVariable =
      (UnsignedIntegerArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateFloatArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   FloatArrayExpressionNode a_oExpressionSelected =
      (FloatArrayExpressionNode)p_oSelNode;
   FloatArrayNode a_oVariable =
      (FloatArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

////////////////////////////////////////////////////////////////////////////////
// function
////////////////////////////////////////////////////////////////////////////////

function bool EvaluateVectorArrayExpression( Node p_oSelNode, VariableNode p_oVariableNode )
{
   VectorArrayExpressionNode a_oExpressionSelected =
      (VectorArrayExpressionNode)p_oSelNode;
   VectorArrayNode a_oVariable =
      (VectorArrayNode)p_oVariableNode;
   if( a_oExpressionSelected.Count == 0 )
   {
      return true;
   }
   else
   if( a_oExpressionSelected.Count == a_oVariable.Count )
   {
      return true;
   }

   return false;
}

