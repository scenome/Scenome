////////////////////////////////////////////////////////////////////////////////
// $file             CREATE_TYPE_TREE.SSL
// $author           Scenomics LLC
// $privacy          PUBLIC
// $description      This script implements automatic generation for node properties.
// $legal            Reserved * r_rLegal
//
// Copyright 2004-2014 Scenomics LLC. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////

library SpaTypeTreeUtil;

import library "interface_util.ssl";
import library "list_util.ssl";
import library "message_util.ssl";
import library "module_util.ssl";
import library "str_list_util.ssl";

///////////////////////////////////////////////////////////////////////////////
// WARNING
///////////////////////////////////////////////////////////////////////////////

// THIS SCRIPT IS AUTOMATICALLY GENERATED. LOCAL CHANGES WILL BE OVERWRITTEN.

///////////////////////////////////////////////////////////////////////////////
// function
///////////////////////////////////////////////////////////////////////////////

function void CreateTypeTree( List p_lTypeRepNodes )
{
   // This must remain synchronized with the list in DataMemberNodeItems.cpp.
   string a_sObjectPropertyType     = "object <T>";
   string a_sBoolPropertyType       = "bool";
   string a_sIntPropertyType        = "int";
   string a_sStringPropertyType     = "string";
   string a_sFloatPropertyType      = "float";
   string a_sDoublePropertyType     = "double";
   string a_sCoordPropertyType      = "coord";
   string a_sEnumPropertyType       = "enumeration";
   string a_sEnumItemPropertyType   = "enumeration item";
   string a_sFilePathPropertyType   = "file path";
   string a_sNodeRefPropertyType    = "node reference";
   string a_sColorPropertyType      = "color";

   for( int nodes = 0; nodes < p_lTypeRepNodes.GetCount(); ++nodes )
   {
      TypeRepNode a_oTypeRepNode = (TypeRepNode)p_lTypeRepNodes.Get( nodes );
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AcceleratorElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "AcceleratorElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AccessControlNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements public and private regions for modules.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "AccessControlNode" );

         DataMemberNode a_oEnumeratedPropertyAccessControl = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "AccessControl", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsAccessControl;
         a_slEnumerationItemsAccessControl.Add( "Public" );
         a_slEnumerationItemsAccessControl.Add( "Sets the default access control level to public." );
         a_slEnumerationItemsAccessControl.Add( "Protected" );
         a_slEnumerationItemsAccessControl.Add( "Sets the default access control level to protected." );
         a_slEnumerationItemsAccessControl.Add( "Private" );
         a_slEnumerationItemsAccessControl.Add( "Sets the default access control level to private." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyAccessControl, a_slEnumerationItemsAccessControl, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ActiveViewElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ActiveViewElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AddChannelModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier implements an attributes channel for its parent mesh. Attribute types include texture, normal, color, position, and data.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "AddChannelModifier" );

         DataMemberNode a_oEnumeratedPropertyAttribute = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Attribute", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsAttribute;
         a_slEnumerationItemsAttribute.Add( "Position" );
         a_slEnumerationItemsAttribute.Add( "This channel type stores up to four double-precision values for vertex positions." );
         a_slEnumerationItemsAttribute.Add( "Normal" );
         a_slEnumerationItemsAttribute.Add( "This channel type stores up to four double-precision values for vertex normals." );
         a_slEnumerationItemsAttribute.Add( "Color" );
         a_slEnumerationItemsAttribute.Add( "This channel type stores up to four integers for vertex colors." );
         a_slEnumerationItemsAttribute.Add( "Texture Coordinates" );
         a_slEnumerationItemsAttribute.Add( "This channel type stores up to four double-precision values for vertex texture coordinates." );
         a_slEnumerationItemsAttribute.Add( "Integer Data" );
         a_slEnumerationItemsAttribute.Add( "This channel stores integer values for associated vertices, such as for skeletal animation data." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyAttribute, a_slEnumerationItemsAttribute, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyDimension = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dimension", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsDimension;
         a_slEnumerationItemsDimension.Add( "1D" );
         a_slEnumerationItemsDimension.Add( "Uses 1 coordinate value to store values for the attribute channel." );
         a_slEnumerationItemsDimension.Add( "2D" );
         a_slEnumerationItemsDimension.Add( "Uses 2 coordinate values to store values for the attribute channel." );
         a_slEnumerationItemsDimension.Add( "3D" );
         a_slEnumerationItemsDimension.Add( "Uses 3 coordinate values to store values for the attribute channel." );
         a_slEnumerationItemsDimension.Add( "4D" );
         a_slEnumerationItemsDimension.Add( "Uses 3 coordinate values to store values for the attribute channel." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyDimension, a_slEnumerationItemsDimension, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AppDefinitionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to specify a Scenome application and to set its basic content.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "AppDefinitionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Application Path", a_sFilePathPropertyType, "", "The .SCENOMEAPP file into which you wish to write the application." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Interface Path", a_sFilePathPropertyType, "", "The .XML file containing the interface definition." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Icon Path", a_sFilePathPropertyType, "", "The .BMP file that contains the splash screen imagery." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Splash Path", a_sFilePathPropertyType, "", "The .ICO file containing the shell icons." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Database Path", a_sFilePathPropertyType, "", "The .BOX file containing the default database that is displayed upon application startup." );
         a_oTypeRepNode.TypeStatus = 1;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AppScaffoldNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to specify a Scenome application and to set its basic content.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "AppScaffoldNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Application Path", a_sFilePathPropertyType, "", "The .SCENOMEAPP file into which you wish to write the application." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Interface Path", a_sFilePathPropertyType, "", "The .XML file containing the interface definition." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Icon Path", a_sFilePathPropertyType, "", "The .BMP file that contains the splash screen imagery." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Splash Path", a_sFilePathPropertyType, "", "The .ICO file containing the shell icons." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Database Path", a_sFilePathPropertyType, "", "The .BOX file containing the default database that is displayed upon application startup." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ApplicationConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to specify a project that contains one or more applications.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ApplicationConfigNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "AttributeModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node enumerates the current mesh attribute channels with <strong>True</strong> and <strong>False</strong> values. The property sheet then provides property sheet edit controls for attribute channels set as <strong>True</strong>. This allows you to edit position, normal, texcoord, color, and integer data channels by hand, using standard floating point, integer, and color edit controls.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "AttributeModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position [ channel index ]", a_sIntPropertyType, "", "Enumerates the position channel at [ channel index ] and provides a Boolean flag that determines whether or not position values in channel [ channel index ] are editable in this property sheet." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Normal [ channel index ]", a_sIntPropertyType, "", "Enumerates the normal channel at [ channel index ] and provides a Boolean flag that determines whether or not normal values in channel [ channel index ] are editable in this property sheet." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Color [ channel index ]", a_sIntPropertyType, "", "Enumerates the color channel at [ channel index ] and provides a Boolean flag that determines whether or not color values in channel [ channel index ] are editable in this property sheet." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture Coordinates [ channel index ]", a_sIntPropertyType, "", "Enumerates the texture coordinates channel at [ channel index ] and provides a Boolean flag that determines whether or not texture coordinate values in channel [ channel index n] are editable in this property sheet." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Integer Data [ channel index ]", a_sIntPropertyType, "", "Enumerates the integer data channel at [ channel index ] and provides a Boolean flag that determines whether or not integer data values in channel [ channel index ] are editable in this property sheet." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BevelModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the BevelModifier.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BevelModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius", a_sDoublePropertyType, "", "Determines the radius ( in database units ) of the bevel's chamfer when <strong>Radius Mathematics</strong> is set to <strong>Distance</strong>. Otherwise, this value is a percentage of edge length from 0.0 to 1.0. Beveling on a particular edge always terminates once 100% of the edge's length has been consumed." );

         DataMemberNode a_oEnumeratedPropertyRadiusMathematics = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius Mathematics", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsRadiusMathematics;
         a_slEnumerationItemsRadiusMathematics.Add( "Units" );
         a_slEnumerationItemsRadiusMathematics.Add( "Performs the bevel with radius in units along spoke edges. This produces a very uniform bevel." );
         a_slEnumerationItemsRadiusMathematics.Add( "Percentage" );
         a_slEnumerationItemsRadiusMathematics.Add( "Performs the bevel with radius in percent of spoke edge length. This can produce a less uniform bevel when edge lengths are generally unequal." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyRadiusMathematics, a_slEnumerationItemsRadiusMathematics, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Skip Collapse", a_sBoolPropertyType, "", "Determines the final appearance: when <b>false</b> the bevel has the typical, smooth appearance." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BevelVertexModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the BevelVertexModifier.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BevelVertexModifier" );

         DataMemberNode a_oEnumeratedPropertyBevelExtrudeMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Bevel/Extrude Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsBevelExtrudeMode;
         a_slEnumerationItemsBevelExtrudeMode.Add( "Percentage" );
         a_slEnumerationItemsBevelExtrudeMode.Add( "Performs the bevel with radius in percent of spoke edge length. This can produce a less uniform bevel when edge lengths are generally unequal." );
         a_slEnumerationItemsBevelExtrudeMode.Add( "Distance" );
         a_slEnumerationItemsBevelExtrudeMode.Add( "Performs the bevel with radius in database units along spoke edges. This produces a very uniform bevel." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyBevelExtrudeMode, a_slEnumerationItemsBevelExtrudeMode, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius", a_sDoublePropertyType, "", "Determines the radius ( in database units ) of the bevel's chamfer when <strong>Radius Mathematics</strong> is set to <strong>Distance</strong>. Otherwise, this value is a percentage of edge length from 0.0 to 1.0. Beveling on a particular edge always terminates once 100% of the edge's length has been consumed." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BinaryOperatorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a user-selectable ( GLSL ) binary expression operator.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "BinaryOperatorNode" );

         DataMemberNode a_oEnumeratedPropertyOperator = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Operator", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsOperator;
         a_slEnumerationItemsOperator.Add( "Assign" );
         a_slEnumerationItemsOperator.Add( "Sets the operator to assign." );
         a_slEnumerationItemsOperator.Add( "Add" );
         a_slEnumerationItemsOperator.Add( "Sets the operator to add." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyOperator, a_slEnumerationItemsOperator, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type implements an expression that accepts BooleanArrayNode as inputs. Like the BooleanArrayNode, this type implements an array of Boolean values, using an IntArray to store the underlying true or false states of elements in the array.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BooleanArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type implements an array of Boolean values, using an IntArray to store the underlying true or false states of elements in the array.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BooleanArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type implements a Boolean expression. This expression can be formed with or without a data source, and all coercion and promotion is handled internally.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BooleanExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the BooleanNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "BooleanNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Value", a_sBoolPropertyType, "", "The value of the BooleanNode, either <b>True</b> or <b>False</b>." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanVectorArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "BooleanVectorArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanVectorArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "BooleanVectorArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanVectorExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "BooleanVectorExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BooleanVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "BooleanVectorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "BoxPrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the BoxPrimitive. The BoxPrimitive produces rectangular prisms such as cubes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "BoxPrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum X", a_sFloatPropertyType, "", "Displays the minimum box coordinate on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Y", a_sFloatPropertyType, "", "Displays the minimum box coordinate on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Z", a_sFloatPropertyType, "", "Displays the minimum box coordinate on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum X", a_sFloatPropertyType, "", "Displays the maximum box coordinate on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Y", a_sFloatPropertyType, "", "Displays the maximum box coordinate on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Z", a_sFloatPropertyType, "", "Displays the maximum box coordinate on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "Links the modifier to a Material node. This applies the Material to all the faces in the box." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "X Resolution", a_sIntPropertyType, "", "Sets the box's tessellation on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Y Resolution", a_sIntPropertyType, "", "Sets the box's tessellation on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Z Resolution", a_sIntPropertyType, "", "Sets the box's tessellation on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Apply Texture Modifier", a_sBoolPropertyType, "", "Determines whether or not the box is used to project texture coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Triangulate", a_sBoolPropertyType, "", "Determines whether or not the box's triangle edges are hidden." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Facing Interior", a_sBoolPropertyType, "", "Reverses vertex winding so the box's faces point inward." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CalculateNormalsModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the CalculateNormalsModifier.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "CalculateNormalsModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Crease Angle", a_sFloatPropertyType, "", "Sets the maximum crease angle across which smooth shading is calculated. Range is <b>0</b> to <b>180</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Face Normal Weight", a_sFloatPropertyType, "", "Sets the maximum face weighting for smooth shading. Range is <b>0</b> to <b>1</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "AddChannelModifier of Attribute Type 'Texture Coordinates'.", a_sNodeRefPropertyType, "", "Specifies the texture coordinates channel of the normal map, if a Texture-based normal map is used." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Normal Attributes Channel ( for the Normal ).", a_sNodeRefPropertyType, "", "Specifies the AddChannelModifier into which this modifier assigns computed normal values. The AddChannelModifier must be of attribute type 'Normal'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Normal Attributes Channel ( for the Tangent ).", a_sNodeRefPropertyType, "", "Specifies the AddChannelModifier into which this modifier assigns computed tangent values. The AddChannelModifier must be of attribute type 'Normal'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Normal Attributes Channel ( for the Binormal ).", a_sNodeRefPropertyType, "", "Specifies the AddChannelModifier into which this modifier assigns computed binormal values. The AddChannelModifier must be of attribute type 'Normal'." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Camera" )
      {
         // Document the node.
         string a_sTypeDocumentation = "Camera nodes store view position, orientation, and clip plane parameters. Scenome applications have an internal camera that is linked to the worksheet. This internal camera controls display and rendering.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Camera" );

         DataMemberNode a_oEnumeratedPropertyCameraMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Camera Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCameraMode;
         a_slEnumerationItemsCameraMode.Add( "None" );
         a_slEnumerationItemsCameraMode.Add( "This sets the Camera mode to standard behavior, whereby it stores ( and can restore ) a view position." );
         a_slEnumerationItemsCameraMode.Add( "Live (Store to Device)" );
         a_slEnumerationItemsCameraMode.Add( "This sets the Camera to store its settings in a LightCameraStateNode." );
         a_slEnumerationItemsCameraMode.Add( "Live (Load from Device)" );
         a_slEnumerationItemsCameraMode.Add( "This sets the Camera to load its settings from a Camera or LightCameraStateNode." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCameraMode, a_slEnumerationItemsCameraMode, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Camera Data Source.", a_sNodeRefPropertyType, "", "Specifies the Camera or LightCameraState used as the Camera data source ( for load and store operations )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "This sets the camera position on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "This sets the camera position on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "This sets the camera position on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation X", a_sFloatPropertyType, "", "This sets the camera orientation on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Y", a_sFloatPropertyType, "", "This sets the camera orientation on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Z", a_sFloatPropertyType, "", "This sets the camera orientation on the Z axis." );

         DataMemberNode a_oEnumeratedPropertyCameraProjection = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Camera Projection", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCameraProjection;
         a_slEnumerationItemsCameraProjection.Add( "Perspective" );
         a_slEnumerationItemsCameraProjection.Add( "This sets the camera mode to perspective projection." );
         a_slEnumerationItemsCameraProjection.Add( "Top" );
         a_slEnumerationItemsCameraProjection.Add( "This sets the camera mode to top projection." );
         a_slEnumerationItemsCameraProjection.Add( "Front" );
         a_slEnumerationItemsCameraProjection.Add( "This sets the camera mode to front projection." );
         a_slEnumerationItemsCameraProjection.Add( "Side" );
         a_slEnumerationItemsCameraProjection.Add( "This sets the camera mode to side projection." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCameraProjection, a_slEnumerationItemsCameraProjection, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Zoom", a_sFloatPropertyType, "", "This sets the camera zoom." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Near Clipping Plane", a_sFloatPropertyType, "", "This sets the near clipping plane." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Far Clipping Plane", a_sFloatPropertyType, "", "This sets the far clipping plane." );

         DataMemberNode a_oEnumeratedPropertyViewportMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Viewport Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsViewportMode;
         a_slEnumerationItemsViewportMode.Add( "Inherit State" );
         a_slEnumerationItemsViewportMode.Add( "Undocumented at present." );
         a_slEnumerationItemsViewportMode.Add( "Set Fragment Coords" );
         a_slEnumerationItemsViewportMode.Add( "Undocumented at present." );
         a_slEnumerationItemsViewportMode.Add( "Set Normalized Coords" );
         a_slEnumerationItemsViewportMode.Add( "Undocumented at present." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyViewportMode, a_slEnumerationItemsViewportMode, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Viewport Min X", a_sFloatPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Viewport Min Y", a_sFloatPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Viewport Size X", a_sFloatPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Viewport Size Y", a_sFloatPropertyType, "", "Undocumented at present." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CameraStateNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the CameraStateNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "CameraStateNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source.", a_sNodeRefPropertyType, "", "The Light from which you wish to read 'camera state' information. You might use this to set up a Camera that uses the Light's 'view' for shadow mapping." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CategoryGroup" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node has been deprecated. Included for compatibility purposes only.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "CategoryGroup" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CircleBezier_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a two-segment Bezier curve in the shape of a circle from the center point and radius clicks defined by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "CircleBezier_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CirclePrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the CirclePrimitive, which produces tessellated geometry shaped like a circle.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "CirclePrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center X", a_sFloatPropertyType, "", "Sets the circle's center position on the X axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center Y", a_sFloatPropertyType, "", "Sets the circle's center position on the Y axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius", a_sFloatPropertyType, "", "Sets the circle's radius in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "Links the modifier to a Material node. This applies the Material to all the faces in the circle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius Resolution", a_sIntPropertyType, "", "Sets the circle's tessellation on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Angle", a_sFloatPropertyType, "", "Sets the circle's starting angle. 0 means the circle starts at 0 degrees from the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Angle", a_sFloatPropertyType, "", "Sets the circle's ending angle. 90 means the circle ends at 90 degrees from the Y axis ( the circle ends on the X axis )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Triangulate", a_sBoolPropertyType, "", "Determines whether or not the circle's triangle edges are hidden." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ClearBuffersNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements GPU buffer management features.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ClearBuffersNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Clear Color Buffer", a_sBoolPropertyType, "", "Determines whether or not this node clears the color buffer when it is traversed." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Clear Depth Buffer", a_sBoolPropertyType, "", "Determines whether or not this node clears the depth buffer when it is traversed." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Color Value", a_sColorPropertyType, "", "Determines the color to which the color buffer is cleared." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Depth Value", a_sFloatPropertyType, "", "Determines the value to which the depth buffer is cleared. -1.0 is a typical value." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CollapseVertexModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements vertex collapsing.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "CollapseVertexModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CollectionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements selection set functionality.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "CollectionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ColorArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines and stores an array of color values ( this is a vec4 type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ColorArrayNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Array Dimension", a_sIntPropertyType, "", "Sets the dimension of the array. Maximum array size is determined by the OpenGL implementation on the active hardware." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Color 0, Color 1, ... Color N", a_sColorPropertyType, "", "Sets the color value for each member of the array." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Alpha 0, Alpha 1, ... Alpha N", a_sDoublePropertyType, "", "Sets the alpha value for each member of the array." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ColorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a single color value ( this is a vec4 type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ColorNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Color", a_sColorPropertyType, "", "Sets the color value." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CommandConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a container for storing CommandRepNodes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "CommandConfigNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CommandRepNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to create a graph-based representation of a command, its command category, GUID, documentation, status, and mode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "CommandRepNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Command Name", a_sStringPropertyType, "", "The command name ( following the macro declaration ). For example: the command name in the declaration 'macro myCommand' is 'MyCommand'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Command Category", a_sStringPropertyType, "", "The command category following the macro declaration. The command category is declared in the macro as follows: 'Category=\"Create Commands\"." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Command Documentation", a_sStringPropertyType, "", "A short description ( a single sentence ) that describes what the command does. This is used on the command documentation page and interface documentation." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Documentation Path", a_sStringPropertyType, "", "An absolute or relative path to extended documentation ( usually .TXT, .HTM, .STM ) on the disk." );

         DataMemberNode a_oEnumeratedPropertyCommandStatus = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Command Status", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCommandStatus;
         a_slEnumerationItemsCommandStatus.Add( "Deprecated" );
         a_slEnumerationItemsCommandStatus.Add( "Marks the command as deprecated which means it should removed from the SSL code base and cannot be instanced in any active user interface." );
         a_slEnumerationItemsCommandStatus.Add( "Compatibility" );
         a_slEnumerationItemsCommandStatus.Add( "Marks the command as remaining for compatibility which means it can be used if it exists but you should not create new instances of this command." );
         a_slEnumerationItemsCommandStatus.Add( "Active" );
         a_slEnumerationItemsCommandStatus.Add( "Marks the command as active which means it can be used without reservation." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCommandStatus, a_slEnumerationItemsCommandStatus, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyCommandMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Command Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCommandMode;
         a_slEnumerationItemsCommandMode.Add( "Release" );
         a_slEnumerationItemsCommandMode.Add( "This option is reserved for future use." );
         a_slEnumerationItemsCommandMode.Add( "Debug" );
         a_slEnumerationItemsCommandMode.Add( "This option is reserved for future use." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCommandMode, a_slEnumerationItemsCommandMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ConditionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ConditionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements base project configuration parameters such as folder and file paths, build info display, and build function. Subclasses such as ApplicationConfigNode and HelpConfigNode are used instead of directly using ConfigNode. ";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ConfigNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Show Information", a_sBoolPropertyType, "", "Show information generated by BUILD or REFRESH commands ( or other commands, if applicable )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Show Warnings", a_sBoolPropertyType, "", "Show warnings generated by BUILD or REFRESH commands ( or other commands, if applicable )." );

         DataMemberNode a_oEnumeratedPropertyDefaultPath = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Default Path", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsDefaultPath;
         a_slEnumerationItemsDefaultPath.Add( "None" );
         a_slEnumerationItemsDefaultPath.Add( "Specifies that no path ( unless there is a <strong>Default Path Data Source</strong> ) will be used to try and restore the <strong>Base Path</strong> parameter." );
         a_slEnumerationItemsDefaultPath.Add( "Application Binaries Path" );
         a_slEnumerationItemsDefaultPath.Add( "Uses the application binaries path to try and restore the <strong>Base Path</strong> parameter." );
         a_slEnumerationItemsDefaultPath.Add( "Application Data Path" );
         a_slEnumerationItemsDefaultPath.Add( "Uses the application data path to try and restore the <strong>Base Path</strong> parameter." );
         a_slEnumerationItemsDefaultPath.Add( "Application Documents Path" );
         a_slEnumerationItemsDefaultPath.Add( "Uses the application documents path to try and restore the <strong>Base Path</strong> parameter." );
         a_slEnumerationItemsDefaultPath.Add( "Current Document Folder" );
         a_slEnumerationItemsDefaultPath.Add( "Uses the current document's folder ( document file path - document file name ) to try and restore the <strong>Base Path</strong> parameter." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyDefaultPath, a_slEnumerationItemsDefaultPath, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Default Path Data Source", a_sNodeRefPropertyType, "", "Specifies a ConfigNode derived type, such as a HelpConfigNode, from which the <strong>Base Path</strong> value will be derived. The <strong>Default Path Data Source</strong> must be set to <strong>None</strong> in order for this parameter to be used." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Base Path", a_sStringPropertyType, "", "This sets the path or folder. Root-level ConfigNode derived types, such as ApplicationConfigNode, must have an absolute path for their <strong>Base Path</strong> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "OnBuild Function", a_sStringPropertyType, "", "This is an SSL function that will be executed when a Build command is invoked. ( See the macro HierarchyBuildAll() for an example )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ConnectModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements edge and vertex connection features for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "ConnectModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ContextMenuElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ContextMenuElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ControlDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ControlDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ControlSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ControlSourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "CylinderPrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the CylinderPrimitive, which produces tessellated geometry shaped like a cylinder.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "CylinderPrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center X", a_sFloatPropertyType, "", "Sets center of the cylinder on the X axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center Y", a_sFloatPropertyType, "", "Sets center of the cylinder on the Y axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Base Z", a_sFloatPropertyType, "", "Sets foot of the cylinder on the Z axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius", a_sFloatPropertyType, "", "Sets the radius of the cylinder in world coordinates, using  <b>Center X</b> and <b>Center Y</b> as the frame of reference." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Height", a_sFloatPropertyType, "", "Sets the height of the cylinder in world coordinates, using  <b>Base Z</b> as the frame of reference." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "Links the modifier to a Material node. This applies the Material to all the faces in the cylinder." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius Resolution", a_sIntPropertyType, "", "Sets the geometric resolution of the cylinder around its circumference." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Z Resolution", a_sIntPropertyType, "", "Sets the geometric resolution of the cylinder on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Triangulate", a_sBoolPropertyType, "", "Determines whether or not the cylinder's triangle edges are hidden." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Apply Texture Modifier", a_sBoolPropertyType, "", "Determines whether or not the cylinder is used to project texture coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Radius Texture", a_sFloatPropertyType, "", "Determines the location around the circumference at which to start texture coordinate flow. 0.0 is a common value." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Height Texture", a_sFloatPropertyType, "", "Determines the location along the cylinder's height at which to start texture coordinate flow. 0.0 is a common value." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Radius Texture", a_sFloatPropertyType, "", "Determines the location around the circumference at which to stop texture coordinate flow. 1.0 or 2.0 or 3.0 are common values." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Height Texture", a_sFloatPropertyType, "", "Determines the location along the cylinder's height at which to stop texture coordinate flow. 1.0 or 2.0 or 3.0 are common values." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DataConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "DataConfigNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DataMemberNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the DataMemberNode, which allows you to create node type layouts for project management and documentation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DataMemberNode" );

         DataMemberNode a_oEnumeratedPropertyPropertyItemType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Property Item Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsPropertyItemType;
         a_slEnumerationItemsPropertyItemType.Add( "object <T>" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item as a non-primitive type." );
         a_slEnumerationItemsPropertyItemType.Add( "bool" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as bool." );
         a_slEnumerationItemsPropertyItemType.Add( "int" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as int." );
         a_slEnumerationItemsPropertyItemType.Add( "float" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as float." );
         a_slEnumerationItemsPropertyItemType.Add( "double" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as double." );
         a_slEnumerationItemsPropertyItemType.Add( "coord" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as coord." );
         a_slEnumerationItemsPropertyItemType.Add( "enumeration" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as an enumeration." );
         a_slEnumerationItemsPropertyItemType.Add( "enumeration item" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as an enumeration item." );
         a_slEnumerationItemsPropertyItemType.Add( "file path" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as file path." );
         a_slEnumerationItemsPropertyItemType.Add( "node reference" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as node reference ( pointer-to-node, usually via NodeSink )." );
         a_slEnumerationItemsPropertyItemType.Add( "node reference" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as node reference ( pointer-to-node )." );
         a_slEnumerationItemsPropertyItemType.Add( "color" );
         a_slEnumerationItemsPropertyItemType.Add( "Specifies the property item type as color." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyPropertyItemType, a_slEnumerationItemsPropertyItemType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Object Type <T>", a_sStringPropertyType, "", "Specifies a concrete type for <T> if 'object <T>' is the property item type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Documentation", a_sStringPropertyType, "", "The documentation for the property item." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DataPaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "DataPaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to create a declaration that includes layout qualifiers, standard qualifiers, and a type such as a struct or float.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "DeclarationNode" );

         DataMemberNode a_oEnumeratedPropertyDeclarationType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Declaration Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsDeclarationType;
         a_slEnumerationItemsDeclarationType.Add( "None" );
         a_slEnumerationItemsDeclarationType.Add( "Does not specify any declaration type. Use this option if you want unvalidated declarations ( which can be useful )." );
         a_slEnumerationItemsDeclarationType.Add( "bool" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a bool declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "int" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies an int declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "float" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a float declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "double" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a double declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "vec" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a vector declaration ( such as vec2, vec3, or vec4 ). This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "mat" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a matrix declaration ( such as mat2, mat3x3, or mat4 ). This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "mat" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a matrix declaration ( such as mat2, mat3x3, or mat4 ). This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "interface block" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies an interface block declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "uniform buffer" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a uniform buffer declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "shader buffer" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a shader buffer declaration. This will be validated." );
         a_slEnumerationItemsDeclarationType.Add( "layout" );
         a_slEnumerationItemsDeclarationType.Add( "Specifies a layout declaration. This will be validated." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyDeclarationType, a_slEnumerationItemsDeclarationType, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DeclareFunctionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to lay out a function call with up to 32 parameters.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DeclareFunctionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Insert Newline Before Opening Brace", a_sBoolPropertyType, "", "Set this parameter to <b>TRUE</b> if you want a new line before the opening brace." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use Const Qualifier", a_sBoolPropertyType, "", "Declares the function with the 'const' qualifier." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use Subroutine Qualifier", a_sBoolPropertyType, "", "Declares the function with the 'subroutine' qualifier." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use Uniform Qualifier", a_sBoolPropertyType, "", "Declares the function with the 'uniform' qualifier." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 0", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 1", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 2", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 3", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 4", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 5", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 6", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Subroutine Declaration Data Source 7", a_sNodeRefPropertyType, "", "Allows you to link a function declared with the subroutine qualifier to a DeclareFunctionNode of a particular subroutine type." );

         DataMemberNode a_oEnumeratedPropertyReturnType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Return Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsReturnType;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyReturnType, a_slEnumerationItemsReturnType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Return Value Explicit Array Size", a_sIntPropertyType, "", "Sets the size of the return value array, if applicable. Arrays returned from functions must be explicitly sized." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Return Type Data Source", a_sNodeRefPropertyType, "", "Provides a link to a node representing a user-defined type such as a struct or variable. Otherwise, uses the <b>Return Type</b> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Function Name", a_sNodeRefPropertyType, "", "Sets the name of the function. This must adhere to GLSL conventions." );

         DataMemberNode a_oEnumeratedPropertyParameterQualifier = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Parameter Qualifier", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsParameterQualifier;
         a_slEnumerationItemsParameterQualifier.Add( "None" );
         a_slEnumerationItemsParameterQualifier.Add( "Function parameter declared without any parameter qualifier ( Same as using the <b>In</b> parameter qualifier )." );
         a_slEnumerationItemsParameterQualifier.Add( "Const" );
         a_slEnumerationItemsParameterQualifier.Add( "Function parameter declared with 'const' parameter qualifier ( variable in calling context must be 'const' and will remain const inside the function )." );
         a_slEnumerationItemsParameterQualifier.Add( "In" );
         a_slEnumerationItemsParameterQualifier.Add( "Function parameter declared with 'in' parameter qualifier ( value is copied in but not copied out by function )." );
         a_slEnumerationItemsParameterQualifier.Add( "Out" );
         a_slEnumerationItemsParameterQualifier.Add( "Function parameter declared with 'out' parameter qualifier ( value is copied out but not copied in by function )." );
         a_slEnumerationItemsParameterQualifier.Add( "Inout" );
         a_slEnumerationItemsParameterQualifier.Add( "Function parameter declared with 'inout' parameter qualifier ( value is copied in and copied out by function )." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyParameterQualifier, a_slEnumerationItemsParameterQualifier, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyParameterType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Parameter Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsParameterType;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyParameterType, a_slEnumerationItemsParameterType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Parameter Type Data Source", a_sNodeRefPropertyType, "", "Provides a link to a node representing a user-defined type such as a struct. Otherwise, uses the <b>Parameter Type</b> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Parameter Explicit Array Size", a_sIntPropertyType, "", "Sets the function parameter array size. Function parameters that are arrays must be explicitly sized." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Parameter Name", a_sStringPropertyType, "", "Sets the function parameter name." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DelaunayModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements DelaunayTriangulation for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "DelaunayModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DelaunayTrimModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements 3D trimming for modeling, such as when you want to insert a road into terrain.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "DelaunayTrimModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertical T-Junction Tolerance (Divisor)", a_sFloatPropertyType, "", "A vertical t-junction occurs when a cloth mesh vertex almost overlaps the edge of a scissor face. The value you enter is used in the equation <b>1 / value</b> to set the tolerance. A value of 1000 results in a tolerance of ( 1 / 1000 )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scissor", a_sNodeRefPropertyType, "", "This parameter links the modifier to a mesh that functions as the scissor mesh. For example: link this modifier to a road mesh." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DeleteFaceModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements face delete for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "DeleteFaceModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DisplaceModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements vertical displacement for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "DisplaceModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Translation", a_sFloatPropertyType, "", "Sets the amount of displacement along the Z axis. Range is -100,000,000 to 100,000,000." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Displacement File", a_sFilePathPropertyType, "", "Links the modifier to a .DEM, .BMP, or .TGA file on the hard disk." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Starting Corner X", a_sFloatPropertyType, "", "Sets the X starting pixel of the displacement inside the imagery. You might only want to use a specific region of the imagery or you might want to start at 0,0,0." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Starting Corner Y", a_sFloatPropertyType, "", "Sets the Y starting pixel of the displacement inside the imagery. You might only want to use a specific region of the imagery or you might want to start at 0,0,0." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Displacement Width In Pixels", a_sFloatPropertyType, "", "Sets the width ( X ) of the displacement region in pixels, relative to <b>Starting Corner X</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Displacement Length In Pixels", a_sFloatPropertyType, "", "Sets the length ( Y ) of the displacement region in pixels, relative to <b>Starting Corner Y</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use 24-bit Elevation Data", a_sBoolPropertyType, "", "Allows you to use a 24-bit image instead of grayscale. This allows for high precision elevation values with a higher dynamic range than gray scale values." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Elevation", a_sFloatPropertyType, "", "Sets the minimum elevation for the terrain. This parameter is rarely configured by hand." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Elevation", a_sFloatPropertyType, "", "Sets the maximum elevation for the terrain. This parameter is rarely configured by hand." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Overall Minimum Elevation", a_sFloatPropertyType, "", "Sets the overall minimum elevation for the terrain when imagery is used to displace multiple meshes. This parameter has no effect on the displacement for a single Mesh." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Overall Maximum Elevation", a_sFloatPropertyType, "", "Sets the overall maximum elevation for the terrain when imagery is used to displace multiple meshes. This parameter has no effect on the displacement for a single Mesh." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Units Per Pixel X", a_sFloatPropertyType, "", "Sets the X axis spacing between elevation values. This parameter is used to generate normals maps and has no effect on the Mesh. This parameter is rarely configured by hand." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Units Per Pixel Y", a_sFloatPropertyType, "", "Sets the Y axis spacing between elevation values. This parameter is used to generate normals maps and has no effect on the Mesh. This parameter is rarely configured by hand." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DissolveFaceModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements face dissolve for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "DissolveFaceModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DissolveModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements vertex and edge dissolve for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "DissolveModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DissolveTriangleEdgesModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements triangle edge dissolving for meshes composed entirely of quadrilaterals.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "DissolveTriangleEdgesModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DockbarElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "DockbarElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DockedViewElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "DockedViewElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DrawCurveLattice" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a lattice of linear curves that occupy the space from the lower-left corner click to the upper-right corner click provided by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "DrawCurveLattice" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DrawLight_DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a new light at the location of the mouse click specified by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "DrawLight_DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode is the super-class for all other draw modes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicBooleanNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a BooleanNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the Boolean value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicBooleanNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its <b>TRUE</b> or <b>FALSE</b> value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicColorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a ColorNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the color value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicColorNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its color value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicFloatNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a FloatNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the float value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicFloatNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its float value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicIntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an IntegerNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the integer value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicIntegerNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its int value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicLightArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a node that stores arrays of up to 32 lights.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "DynamicLightArrayNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use This Many Lights", a_sIntPropertyType, "", "Sets the number of Lights to create out of a maximum of 512." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Display Properties For The Light At This Index", a_sIntPropertyType, "", "Displays properties for the Light at the indicated index." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Render Light Guides", a_sBoolPropertyType, "", "Displays Light guides." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Broadcast Lights To RenderInfo", a_sBoolPropertyType, "", "Determines whether or not Lights are added to the Light stack and sent to the rendering device." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Name", a_sStringPropertyType, "", "Sets the name of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Class", a_sStringPropertyType, "", "Sets the class of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "ID", a_sStringPropertyType, "", "Sets the ID of the light array member. This must be unique for each member of the array." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Export Disabled", a_sBoolPropertyType, "", "Determines whether or not the Light is exported during an export process, such as to OpenSceneGraph." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Ambient Color", a_sColorPropertyType, "", "Sets the ambient color of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Diffuse Color", a_sColorPropertyType, "", "Sets the diffuse color of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Specular Color", a_sColorPropertyType, "", "Sets the specular color of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Emissive Color", a_sColorPropertyType, "", "Sets the emissive color of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "Sets the X axis position of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "Sets the Y axis position of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "Sets the Z axis position of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation X", a_sFloatPropertyType, "", "Sets the X axis orientation of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Y", a_sFloatPropertyType, "", "Sets the Y axis orientation of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Z", a_sFloatPropertyType, "", "Sets the Z axis orientation of the light array member." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Intensity", a_sFloatPropertyType, "", "Sets the intensity of the light array member. Range is between <b>-100</b> to <b>100</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Constant Attenuation", a_sFloatPropertyType, "", "Sets the base attenuation for the light array member. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Linear Attenuation", a_sFloatPropertyType, "", "Sets the linear attenuation for the light array member. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Quadratic Attenuation", a_sFloatPropertyType, "", "Sets the quadratic attenuation for the light array member. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Spot Exponent", a_sFloatPropertyType, "", "Sets the spot exponent. Range is between <b>0.00001</b> and <b>1000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Aperture X", a_sFloatPropertyType, "", "Sets the X-axis aperture for the Light. Range is between <b>0</b> and <b>180</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Aperture Y", a_sFloatPropertyType, "", "Sets the Y-axis aperture for the Light. Range is between <b>0</b> and <b>180</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadow Map Near Z", a_sFloatPropertyType, "", "Sets the near z clipping value for the Light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadow Map Far Z", a_sFloatPropertyType, "", "Sets the far z clipping value for the Light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Local", a_sBoolPropertyType, "", "This option is undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On", a_sBoolPropertyType, "", "This option turns the light array member on/off like a light switch." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Global", a_sBoolPropertyType, "", "This option determines if the light array member is global, which means that it affects all geometry regardless of its location in the scene." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadows", a_sBoolPropertyType, "", "This option determines if the light array member casts shadows." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dynamic", a_sBoolPropertyType, "", "This option determines if the light array member is dynamic. In Scenome applications, all Lights are dynamic regardless, but this flag may be important for runtime applications." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a MatrixNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the matrix value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicMatrixNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its matrix value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicSamplerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a SamplerNode that can be connected to a ( Texture ) data source. This is useful to valid the relationship between samplers and textures.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicSamplerNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its sampler type can be derived ( or validated against )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicTextureModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements texture generation for terrain built with Scenome's GIS module.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "DynamicTextureModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its sampler type can be derived ( or validated against )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "DynamicVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a VectorNode that can be connected to a data source. This node isn't usually used directly; subclasses contain code for dynamically setting the vector value.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "DynamicVectorNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This parameter links the variable to a data source from which its vector value can be derived." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type is a sub-node type. It is used to implement a command menu for edge-selections ( since an edge-selection is not a &lt;lNode&gt; ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "EdgeModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements edge splitting for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "EdgeModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Percent", a_sDoublePropertyType, "", "This parameter sets the split distance between the A vertex and the B vertex of the edge." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "EditModel3D" )
      {
         // Document the node.
         string a_sTypeDocumentation = "The root node is the top of the hierarchy and is the only node that does not have a parent. If you wish to change the numeric properties or units labeling for a database, root properties contains these settings. Root is a sub-class of group, and it is the only node you cannot delete.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "EditModel3D" );

         DataMemberNode a_oEnumeratedPropertyUnitLabel = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Unit Label", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsUnitLabel;
         a_slEnumerationItemsUnitLabel.Add( "US Inch" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to inches. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "US Foot" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to feet. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "US Mile" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to miles. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "Metric Centimeter" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to centimeters. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "Metric Meter" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to meters. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "Metric Kilometer" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to kilometers. This does not affect coordinate storage." );
         a_slEnumerationItemsUnitLabel.Add( "Degree" );
         a_slEnumerationItemsUnitLabel.Add( "Sets the database unit labels to degrees. This does not affect coordinate storage." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyUnitLabel, a_slEnumerationItemsUnitLabel, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyNumericPrecision = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Numeric Precision", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsNumericPrecision;
         a_slEnumerationItemsNumericPrecision.Add( "Single Precision [32-bit]" );
         a_slEnumerationItemsNumericPrecision.Add( "Sets internal numeric precision to 32-bit. <b>This change can have serious effects and cannot be undone.</b>." );
         a_slEnumerationItemsNumericPrecision.Add( "Single Precision [64-bit]" );
         a_slEnumerationItemsNumericPrecision.Add( "Sets internal numeric precision to 64-bit. <b>This change can have serious effects and cannot be undone.</b>." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyNumericPrecision, a_slEnumerationItemsNumericPrecision, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Unit Scale", a_sFloatPropertyType, "", "This option is reserved for future use." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "EvaluationDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "EvaluationDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "EvaluationSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "EvaluationSourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ExportOptionsModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for configuring GIS terrain generation options.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "ExportOptionsModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Output Rectangle Tessellation X", a_sIntPropertyType, "", "This parameter sets the X axis tessellation value for output terrain." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Output Rectangle Tessellation Y", a_sIntPropertyType, "", "This parameter sets the Y axis tessellation value for output terrain." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Place New Nodes Here", a_sStringPropertyType, "", "The graph address, such as /Database/Output, to place the new terrain Mesh nodes." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Export To This Directory", a_sStringPropertyType, "", "The disk address, such as C:Terrain, to place the new terrain databases." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Number Of Levels To Create", a_sIntPropertyType, "", "Create this many levels of detail. Each level of detail is stored as a separate file on the hard disk." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "LOD 1 Simplify Percent, LOD 2 Simplify Percent", a_sFloatPropertyType, "", "The simplification percent for each level of detail." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Border Pixel Overlap", a_sIntPropertyType, "", "This is a private, debug-only feature." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements dynamic expression handling that can control graph traversal paths.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ExpressionNode" );

         DataMemberNode a_oEnumeratedPropertyNone = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "None", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsNone;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyNone, a_slEnumerationItemsNone, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertySSLScript = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "SSL Script", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsSSLScript;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertySSLScript, a_slEnumerationItemsSSLScript, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyGLSLScript = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "GLSL Script", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsGLSLScript;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyGLSLScript, a_slEnumerationItemsGLSLScript, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type", a_sStringPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Code", a_sStringPropertyType, "", "The SSL or GLSL expression you wish to evaluate." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ExtensionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements GLSL extension testing and configuration. When an extension is unavailable, the node renders with a light gray icon.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ExtensionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Name", a_sStringPropertyType, "", "The name of the OpenGL extension you wish to include." );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "require" );
         a_slEnumerationItemsMode.Add( "Appends the extension with the ': require' flag." );
         a_slEnumerationItemsMode.Add( "warn" );
         a_slEnumerationItemsMode.Add( "Appends the extension with the ': warn' flag." );
         a_slEnumerationItemsMode.Add( "enable" );
         a_slEnumerationItemsMode.Add( "Appends the extension with the ': enable' flag." );
         a_slEnumerationItemsMode.Add( "disable" );
         a_slEnumerationItemsMode.Add( "Appends the extension with the ': disable' flag." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ExtrudeModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the face extrusion for modeling.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "ExtrudeModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "X Axis Extrude Distance", a_sFloatPropertyType, "", "This parameter sets the extrude distance on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Y Axis Extrude Distance", a_sFloatPropertyType, "", "This parameter sets the extrude distance on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Z Axis Extrude Distance", a_sFloatPropertyType, "", "This parameter sets the extrude distance on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertex Normal Extrude Distance", a_sFloatPropertyType, "", "This parameter sets the extrude distance along the vertex normal." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Face Normal Extrude Distance", a_sFloatPropertyType, "", "This parameter sets the extrude distance along the vertex normal." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Extrude Section Count", a_sIntPropertyType, "", "This parameter sets the number of cross-sections created during the extrude." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale Extrude Cap In Units", a_sIntPropertyType, "", "This parameter scales the extrude cap in database units." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type is a sub-node type. It is used to implement a command menu for face-selections ( since a face-selection is not a &lt;lNode&gt; ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FaceAttributeModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier implements editable attributes for each attribute channel stored by the mesh.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "FaceAttributeModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FileConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements file referencing for project management.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "FileConfigNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Absolute Path Info ( Not Editable )", a_sStringPropertyType, "", "This parameter enumerates the absolute path for the FileConfigNode, including any parent nodes of type FolderConfigNode and ConfigNode." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FileNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements file referencing.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "FileNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "File Path", a_sFilePathPropertyType, "", "An absolute or relative path to a file on disk. This file is now referenced by the graph, but is not opened or otherwise manipulated, and creates no memory load on the application." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FloatArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "FloatArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FloatArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines and stores an array of floating point values ( this is a float[] type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FloatArrayNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Array Dimension", a_sIntPropertyType, "", "Sets the dimension of the array. Maximum array size is determined by the OpenGL implementation on the active hardware." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Float 0, Float 1, ... Float N", a_sFloatPropertyType, "", "Sets the float value for each member of the array." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FloatExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements a float expression node capable of creating float expressions from scalar, vector, or matrix variables. This expression can also generate R valued expressions such as float( 1.0 ) if a VariableNode data source is not provided. This node cannot generate an R value expression on the left side of an assignment ( = ) operator because GLSL does not support that concept.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FloatExpressionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Double", a_sDoublePropertyType, "", "This option allows you to specify a float if this node is being used to constructor an R value expression such as float( 1.0 )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FloatNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a single floating point value ( this is a float type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FloatNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Float", a_sFloatPropertyType, "", "Sets the float value." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FolderConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements folder referencing for project management.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "FolderConfigNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Absolute Path Info ( Not Editable )", a_sStringPropertyType, "", "This parameter enumerates the absolute path for the FolderConfigNode, including any parent nodes of type FolderConfigNode and ConfigNode." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "OnRefresh Function", a_sStringPropertyType, "", "This is an SSL function that will be executed when a Refresh command is invoked. ( See the macro HierarchyRefreshNode() for an example )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "This data source connects the FolderConfigNode to another node ( such as an AppDefinitionNode ) that may be used during refresh or build. For example, you might connect to an AppDefinitionNode if you wish to implement an OnRefresh method that rebuilds interface documentation and stores it in this FolderConfigNode." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FragmentDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "FragmentDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FragmentSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "FragmentSourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FrameBuffer" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node configures a frame buffer on the GPU and binds any properly configured texture child nodes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FrameBuffer" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FrameBufferBind" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node initiates buffer binding for FrameBuffer nodes ( which are not necessarily bound when traversed ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FrameBufferBind" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Layer", a_sIntPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture", a_sNodeRefPropertyType, "", "Undocumented at present." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FrameReferenceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements frame-of-reference management for sub-classes such as camera.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "FrameReferenceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FreeHandBezier_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a Bezier curve in the shape of the control curve formed by the mouse clicks provided by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "FreeHandBezier_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FreeHandLinear_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a Linear curve in the shape of the control points formed by the mouse clicks provided by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "FreeHandLinear_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "FunctionParameterNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "FunctionParameterNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This command menu handles multiple selection of different node types.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GeographicProjectionModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier enables geographic projection from latitude/longitude coordinates to Universal Transverse Mercator, Lambert Conformal Conic, or Robinson projection.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "GeographicProjectionModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GeographicTextureModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier enables geographic projection of texture coordinates from latitude/longitude coordinates to Universal Transverse Mercator, Lambert Conformal Conic, or Robinson projection.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "GeographicTextureModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Values Are Already Projected", a_sBoolPropertyType, "", "Set this value if the texture is already projected, such as with ortho-imagery. Height imagery is usually unprojected." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Latitude", a_sFloatPropertyType, "", "This is the minimum latitude, such as 40 ( degrees ), of the unprojected texture. May also be northing coordinates if the imagery is already projected." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Longitude", a_sFloatPropertyType, "", "This is the minimum longitude, such as -127 ( degrees ), of the unprojected texture. May also be easting coordinates if the imagery is already projected." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Latitude", a_sFloatPropertyType, "", "This is the maximum latitude, such as 41 ( degrees ), of the unprojected texture. May also be northing coordinates if the imagery is already projected." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Longitude", a_sFloatPropertyType, "", "This is the maximum longitude, such as -125 ( degrees ), of the unprojected texture. May also be easting coordinates if the imagery is already projected." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material Filter", a_sNodeRefPropertyType, "", "Apply the projection to the Material or NodeLink&#187;Material specified by this node parameter." );

         DataMemberNode a_oEnumeratedPropertyChannel1 = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Channel 1", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsChannel1;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyChannel1, a_slEnumerationItemsChannel1, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GeometryDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "GeometryDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GeometryPaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "GeometryPaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GeometrySourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "GeometrySourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GlslQualifierNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "GlslQualifierNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "GraphMemberNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for validating graph structure.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "GraphMemberNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Function", a_sStringPropertyType, "", "Specifies an SSL function that would like to invoke during validation." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Node Type <T>", a_sStringPropertyType, "", "Specifies a node type for which the GraphMemberNode will operate as an alias." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "NodeLink Type <T>", a_sStringPropertyType, "", "Specifies a node type for a NodeLink target when the GraphMemberNode is operating as a NodeLink alias." );

         DataMemberNode a_oEnumeratedPropertyTypeCheckingMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type Checking Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTypeCheckingMode;
         a_slEnumerationItemsTypeCheckingMode.Add( "None" );
         a_slEnumerationItemsTypeCheckingMode.Add( "Specifies no type checking." );
         a_slEnumerationItemsTypeCheckingMode.Add( "Derived" );
         a_slEnumerationItemsTypeCheckingMode.Add( "Specifies type checking shall consider valid node types derived from <T>." );
         a_slEnumerationItemsTypeCheckingMode.Add( "Exact" );
         a_slEnumerationItemsTypeCheckingMode.Add( "Specifies type checking will test that the node type exactly matches <T>." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTypeCheckingMode, a_slEnumerationItemsTypeCheckingMode, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyTemplateMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Template Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTemplateMode;
         a_slEnumerationItemsTemplateMode.Add( "None" );
         a_slEnumerationItemsTemplateMode.Add( "Specifies no template mode." );
         a_slEnumerationItemsTemplateMode.Add( "Child Type" );
         a_slEnumerationItemsTemplateMode.Add( "Sets the node to operate as an alias for child type checking." );
         a_slEnumerationItemsTemplateMode.Add( "By Graph Address" );
         a_slEnumerationItemsTemplateMode.Add( "Sets the node to operate as an alias for a node at a specific graph address. This makes the node a validation entry point." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTemplateMode, a_slEnumerationItemsTemplateMode, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertySequenceMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Sequence Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsSequenceMode;
         a_slEnumerationItemsSequenceMode.Add( "None" );
         a_slEnumerationItemsSequenceMode.Add( "Specifies no sequence checking." );
         a_slEnumerationItemsSequenceMode.Add( "Explicit Size" );
         a_slEnumerationItemsSequenceMode.Add( "Sets the node to operate as an alias for an explicitly sized sequence of nodes of type <T> using the Type Checking Mode." );
         a_slEnumerationItemsSequenceMode.Add( "Implicit Size" );
         a_slEnumerationItemsSequenceMode.Add( "Sets the node to operate as an alias for an implicitly sized sequence of nodes of type <T> using the Type Checking Mode." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertySequenceMode, a_slEnumerationItemsSequenceMode, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Explicit Sequence Count", a_sIntPropertyType, "", "Specifies the count of the explicitly sized sequence ( if applicable )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Group" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A Group is the most basic \"container\" node that implements position, orientation, and scale properties. Groups can contain any other type of node as a child.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "Group" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Visible", a_sBoolPropertyType, "", "Toggles the Group visible/invisible. Child nodes are not visible when their parent Group is invisible." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Collisions", a_sBoolPropertyType, "", "Toggles collision detection on the Group and its children. This is used for runtime export and has no effect in Scenome applications." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Cull", a_sBoolPropertyType, "", "Toggles view volume culling on/off. modifying this parameter may cause incorrect culling and other unexpected consequences." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Preserve Camera", a_sBoolPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Generic Data Source", a_sNodeRefPropertyType, "", "This option provides the capability to connect a Group to a node that serves as a generic data source." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Bounding Box Frozen", a_sBoolPropertyType, "", "Freezes the bounding box at its current size. This is often used as a runtime flag, and modifying this parameter may cause incorrect culling." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum X", a_sFloatPropertyType, "", "Displays the minimum bounding box coordinate on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Y", a_sFloatPropertyType, "", "Displays the minimum bounding box coordinate on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Z", a_sFloatPropertyType, "", "Displays the minimum bounding box coordinate on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum X", a_sFloatPropertyType, "", "Displays the maximum bounding box coordinate on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Y", a_sFloatPropertyType, "", "Displays the maximum bounding box coordinate on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Z", a_sFloatPropertyType, "", "Displays the maximum bounding box coordinate on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Transform Locked", a_sBoolPropertyType, "", "Locks the node and prevents transformation of the node and its children. This is a runtime flag and has no effect in Scenome applications." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "Displays the node's position on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "Displays the node's position on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "Displays the node's position on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation X", a_sFloatPropertyType, "", "Displays the node's orientation on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Y", a_sFloatPropertyType, "", "Displays the node's orientation on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Z", a_sFloatPropertyType, "", "Displays the node's orientation on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale X", a_sFloatPropertyType, "", "Displays the node's scale on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale Y", a_sFloatPropertyType, "", "Displays the node's scale on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale Z", a_sFloatPropertyType, "", "Displays the node's scale on the Z axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Billboard", a_sBoolPropertyType, "", "Sets the node as a billboard. Billboards rotate to face the camera. This feature has been preserved for compatibility purposes, but this  functionality should be implemented with geometry shaders." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "HelpConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A HelpConfigNode implements documentation-related project settings. It best practice to place HelpConfigNodes as an immediate child of the root node.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "HelpConfigNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Company Name", a_sStringPropertyType, "", "Stores the company name. Should be in the form 'Scenomics LLC'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Company URL", a_sStringPropertyType, "", "Stores the company URL. Should be in the form 'http://www.scenomics.com/'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Author", a_sStringPropertyType, "", "Stores the author. Should be in the form: 'Scenomics LLC' or 'John Doe'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Help Index File", a_sFilePathPropertyType, "", "Stores an absolute or relative path to the help index file, which is the .HTM, .STM, or .TXT file into which the help's tree control is saved. It is best practice to use a relative path that is a sub-directory of the <strong>Base Path</strong> value of the HelpConfigNode." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Help Address", a_sFilePathPropertyType, "", "Stores an absolute or relative path to the help launch file, which a file such as INDEX.HTM, INDEX.STM, or another file that you wish to launch when testing the help. This may also be valid http address, including for local and remote servers. " );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Help Address", a_sFilePathPropertyType, "", "If a disk-based path is used ( rather than http ), it is best practice to use a relative path that is a sub-directory of the <strong>Base Path</strong> value of the HelpConfigNode. " );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Help Address", a_sFilePathPropertyType, "", "For example, if <strong>Base Path</strong> is C:\webserver, then this value should be something like <strong>.\help</strong>. When resolved, the help address will be something like <strong>C:\webwerver\help\index.htm</strong>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Server Root", a_sFilePathPropertyType, "", "Stores an absolute path or relative path to the local server root, such as C:\myserver. This value can only be a relative path if the help is a sub-directory of the directory specified by the node's <strong>Base Path</strong> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Script Input Folder", a_sFilePathPropertyType, "", "Stores an absolute path or relative path to the script data interface documentation input folder, such as .ScriptInputs. This value can only be a relative path if the help is a sub-directory of the directory specified by the node's <strong>Base Path</strong> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Script Output Folder", a_sFilePathPropertyType, "", "Stores an absolute path or relative path to the script data interface documentation output folder, such as .scriptingclasses. This value can only be a relative path if the help is a sub-directory of the directory specified by the node's <strong>Base Path</strong> parameter." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Remote Server Root", a_sFilePathPropertyType, "", "Often an upload must go to a specific sub-folder on a web server. For example, many commercial hosting providers start their FTP servers at a single sub-directory using the customer's account name such as <strong>myaccount</strong> or <strong>webroot</strong>. This parameter should match the initial containing directory on the web server." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Help Contents Title", a_sStringPropertyType, "", "This parameter specifies the help page title. This is the text that appears in a web browser tab ( or the web browser title bar ) when the help is loaded. Generally this value is set to a company or product name such as <strong>Scenomics Online Help</strong>." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IncludePaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IncludePaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IncludeSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IncludeSourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InitializationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "InitializationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InsertQuadCenterVertexModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node inserts a vertex in the center of a quadrilateral.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "InsertQuadCenterVertexModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InsertRegularVertices_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode inserts two curve points into the segment on which the user clicks. The selection filter mode must be set to <b>Segments</b>.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "InsertRegularVertices_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InsertTriangleIntoTriangleModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node inserts a triangle into the center of a triangle.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "InsertTriangleIntoTriangleModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InsertVertexModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node inserts a vertex in the center of a triangle.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "InsertVertexModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InsertVertex_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode inserts new curve points at the location of the mouse click. The selection filter mode must be set to <b>Segments</b>.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "InsertVertex_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InstallerConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "An InstallerConfigNode implements installer-related project settings. It best practice to place InstallerConfigNodes as an immediate child of the root node.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "InstallerConfigNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Installer File", a_sFilePathPropertyType, "", "An absolute or relative path to the installer script file. If relative, this path is resolved from the active document's location on disk." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Server Destination Path", a_sFilePathPropertyType, "", "Often an upload must go to a specific sub-folder on a web server. For example, many commercial hosting providers start their FTP servers at a single sub-directory using the customer's account name such as <strong>myaccount</strong> or <strong>webroot</strong>. This parameter should match the upload destination directory on the web server, such as webroot/downloads/binaries." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InstallerDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "InstallerDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InstallerDirectiveNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "An InstallerDirectiveNode allows to you specify InnoSetup installer directives. The properties of an InstallerDirectiveNode depend on the SectionConfigNode under which the node is parented. Please consult the InnoSetup documentation for further information.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "InstallerDirectiveNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InstallerFlagNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "InstallerFlagNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InstallerParameterNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "InstallerParameterNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines and stores an array of integer point values ( this is an int[] type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "IntegerArrayNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Array Dimension", a_sIntPropertyType, "", "Sets the dimension of the array. Maximum array size is determined by the OpenGL implementation on the active hardware." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Integer 0, Integer 1, ... Integer N", a_sIntPropertyType, "", "Sets the int value for each member of the array." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a single integer value ( this is an int type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "IntegerNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Value", a_sIntPropertyType, "", "Sets the int value." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerVectorArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerVectorArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerVectorArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerVectorArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerVectorExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerVectorExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IntegerVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "IntegerVectorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InterfaceBlockNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for interface block layout.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "InterfaceBlockNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InterfaceElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for application interface layout.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "InterfaceElementNode" );

         DataMemberNode a_oEnumeratedPropertyElement = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Element", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsElement;
         a_slEnumerationItemsElement.Add( "interface" );
         a_slEnumerationItemsElement.Add( "Specifies a root level &lt;interface&gt; element. This element contains all other interface elements." );
         a_slEnumerationItemsElement.Add( "menu" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;menu&gt; element. This element implements the main menu bar." );
         a_slEnumerationItemsElement.Add( "popup" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;popup&gt; element. This element implements popup menus on the main menu, context menus, and toolbars." );
         a_slEnumerationItemsElement.Add( "item" );
         a_slEnumerationItemsElement.Add( "Specifies an &lt;item&gt; element. This element implements specific command items on the main menu, context menus, and toolbars." );
         a_slEnumerationItemsElement.Add( "separator" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;separator&gt; element. This element implements horizontal or vertical separator items on the main menu, context menus, and toolbars." );
         a_slEnumerationItemsElement.Add( "dockbar" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;dockbar&gt; element. This element adds a specific editor ( such as the property editor ) to a specific &lt;dockedview&gt;." );
         a_slEnumerationItemsElement.Add( "dockedview" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;dockedview&gt; element. This element implements specific panel ( which contains 0 more editors ) at a specific dock location. For example: ( top, left ) or ( bottom )." );
         a_slEnumerationItemsElement.Add( "activeview" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;activeview&gt; element. This element specifies which editor ( dockbar ) is active ( on top and has focus )." );
         a_slEnumerationItemsElement.Add( "toolbar" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;toolbar&gt; element." );
         a_slEnumerationItemsElement.Add( "contextmenu" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;contextmenu&gt; element." );
         a_slEnumerationItemsElement.Add( "keyboard" );
         a_slEnumerationItemsElement.Add( "Specifies a &lt;keyboard&gt; element." );
         a_slEnumerationItemsElement.Add( "accelerator" );
         a_slEnumerationItemsElement.Add( "Specifies an &lt;accelerator&gt; element, which is a specific keyboard accelerator." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyElement, a_slEnumerationItemsElement, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyElementStatus = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Element Status", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsElementStatus;
         a_slEnumerationItemsElementStatus.Add( "Not Final Type" );
         a_slEnumerationItemsElementStatus.Add( "Indicates that the context menu is for a type that is not designated as a final type. The icon representing the interface element is red, showing that a context menu will not be generated." );
         a_slEnumerationItemsElementStatus.Add( "Deprecated" );
         a_slEnumerationItemsElementStatus.Add( "Indicates that the context menu ( or command item ) is for an item that has been deprecated. In the case of command menus, this means that no context menu will be generated. Command items with this flag should be removed." );
         a_slEnumerationItemsElementStatus.Add( "Compatibility" );
         a_slEnumerationItemsElementStatus.Add( "Indicates that the context menu ( or command item ) is for a node or command retained for compatibility purposes. Context menu items with this flag should have <b>Properties</b> and <b>Delete</b> commands only." );
         a_slEnumerationItemsElementStatus.Add( "Active" );
         a_slEnumerationItemsElementStatus.Add( "Indicates that the context menu ( or command item ) is active and fully available for use." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyElementStatus, a_slEnumerationItemsElementStatus, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Debug Only", a_sBoolPropertyType, "", "When this property is true, interface elements are only included in debug builds of the application." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "name", a_sStringPropertyType, "", "Sets the name attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "guid", a_sStringPropertyType, "", "Sets the GUID attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "class", a_sStringPropertyType, "", "Sets the class attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "keys", a_sStringPropertyType, "", "Sets the keys attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "version", a_sStringPropertyType, "", "Sets the version attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "dockposition", a_sStringPropertyType, "", "Sets the dockposition attribute of the element." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "images", a_sBoolPropertyType, "", "Sets the images attribute to true or false." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "text", a_sBoolPropertyType, "", "Sets the text attribute to true or false." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "InterfaceSectionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node creates a container for different interface sections, such as menu, context menu, dockbar, and keyboard.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "InterfaceSectionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ItemElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ItemElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "IteratorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for defining loops. Used for GLSL code generation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "IteratorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "JumpStatementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "JumpStatementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "KeyboardElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "KeyboardElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LOD" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements distance-based level-of-detail, whereby the child nodes are drawn only when the camera is within the distance specified by the <b>Switch In</b> and <b>Switch Out</b> values.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "LOD" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Switch In Distance", a_sFloatPropertyType, "", "Determines the distance from the LOD center at which the node is switched in ( made visible )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Switch Out Distance", a_sFloatPropertyType, "", "Determines the distance from the LOD center at which the node is switched out ( made invisible )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "LOD Center X", a_sFloatPropertyType, "", "Sets the X axis position of the LOD center in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "LOD Center Y", a_sFloatPropertyType, "", "Sets the Y axis position of the LOD center in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "LOD Center Z", a_sFloatPropertyType, "", "Sets the Z axis position of the LOD center in world coordinates." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LanguageQualifierNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "LanguageQualifierNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LayoutNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container implementing layout declarations. This class is not used directly. Instead, use subclasses such as GeometryShaderLayoutNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "LayoutNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LibraryConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is used to store project information for collections of files related to a particular project. Any files and folders contained as child nodes are validated during build.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LibraryConfigNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Light" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a light.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Light" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Ambient Color", a_sColorPropertyType, "", "Sets the ambient color of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Diffuse Color", a_sColorPropertyType, "", "Sets the diffuse color of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Specular Color", a_sColorPropertyType, "", "Sets the specular color of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Emissive Color", a_sColorPropertyType, "", "Sets the emissive color of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "Sets the X axis position of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "Sets the Y axis position of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "Sets the Z axis position of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation X", a_sFloatPropertyType, "", "Sets the X axis orientation of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Y", a_sFloatPropertyType, "", "Sets the Y axis orientation of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Z", a_sFloatPropertyType, "", "Sets the Z axis orientation of the light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Intensity", a_sFloatPropertyType, "", "Sets the intensity of the light. Range is between <b>-100</b> to <b>100</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Constant Attenuation", a_sFloatPropertyType, "", "Sets the base attenuation for the light. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Linear Attenuation", a_sFloatPropertyType, "", "Sets the linear attenuation for the light. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Quadratic Attenuation", a_sFloatPropertyType, "", "Sets the quadratic attenuation for the light. Range is between <b>0.00001</b> and <b>10000000000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Spot Exponent", a_sFloatPropertyType, "", "Sets the spot exponent. Range is between <b>0.00001</b> and <b>1000</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Aperture X", a_sFloatPropertyType, "", "Sets the X-axis aperture for the Light. Range is between <b>0</b> and <b>180</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Aperture Y", a_sFloatPropertyType, "", "Sets the Y-axis aperture for the Light. Range is between <b>0</b> and <b>180</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadow Map Near Z", a_sFloatPropertyType, "", "Sets the near z clipping value for the Light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadow Map Far Z", a_sFloatPropertyType, "", "Sets the far z clipping value for the Light." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Local", a_sBoolPropertyType, "", "This option is undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On", a_sBoolPropertyType, "", "This option turns the light on/off like a light switch." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Global", a_sBoolPropertyType, "", "This option determines if the light is global, which means that it affects all geometry regardless of its location in the scene." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shadows", a_sBoolPropertyType, "", "This option determines if the light casts shadows." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dynamic", a_sBoolPropertyType, "", "This option determines if the light is dynamic. In Scenome applications, all Lights are dynamic regardless, but this flag may be important for runtime applications." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "LightArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightBooleanNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a BooleanNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightBooleanNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "isLightOn" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source's <b>On</b> flag is <b>True</b> or <b>False</b>." );
         a_slEnumerationItemsMode.Add( "isLightGlobal" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source's <b>Global</b> flag is <b>True</b> or <b>False</b>." );
         a_slEnumerationItemsMode.Add( "isLightShadows" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source's <b>Shadow</b> flag is <b>True</b> or <b>False</b>." );
         a_slEnumerationItemsMode.Add( "isLightDynamic" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source's <b>Dynamic</b> flag is <b>True</b> or <b>False</b>." );
         a_slEnumerationItemsMode.Add( "isLightInfinite" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source is an infinite light ( like the sun )." );
         a_slEnumerationItemsMode.Add( "isLightPoint" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source is a point light." );
         a_slEnumerationItemsMode.Add( "isLightSpot" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute whether or not the Light data source is a spotlight." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightCameraStateNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a node that is capable of transmitting light info to a camera";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightCameraStateNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "The Light from which you wish to read 'camera state' information. You might use this to set up a Camera that uses the Light's 'view' for shadow mapping." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightColorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a ColorNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightColorNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightAmbientColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's ambient color." );
         a_slEnumerationItemsMode.Add( "lightDiffuseColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's diffuse color." );
         a_slEnumerationItemsMode.Add( "lightSpecularColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's specular color." );
         a_slEnumerationItemsMode.Add( "lightEmissiveColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's emissive color." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightCountNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an IntegerNode that computes the active light count, either from a LightStackNode data source, or from the RenderInfo ( which requires no data source ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightCountNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightSourceCount" );
         a_slEnumerationItemsMode.Add( "Sets the mode to the light count of the LightStackNode data source or from the active document's RenderInfo." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightFloatNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a FloatNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightFloatNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightSpotExponent" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's spot exponent." );
         a_slEnumerationItemsMode.Add( "lightSpotCutoff" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's spot cutoff angle." );
         a_slEnumerationItemsMode.Add( "lightSpotCosCutoff" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the cosine of the Light data source's spot cutoff angle." );
         a_slEnumerationItemsMode.Add( "lightConstantAttenuation" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's constant attenuation." );
         a_slEnumerationItemsMode.Add( "lightLinearAttenuation" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's linear attenuation." );
         a_slEnumerationItemsMode.Add( "lightQuadraticAttenuation" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's quadratic attenuation." );
         a_slEnumerationItemsMode.Add( "lightIntensity" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Light data source's intensity." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightIntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an IntegerNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightIntegerNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightMode" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute an integer representing the Light's type. 0 = infinite, 1 = point, 2 = spot." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a MatrixNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightMatrixNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightModelViewCameraMatrix" );
         a_slEnumerationItemsMode.Add( "Computes the ModelViewCamera matrix from the Light's point of view." );
         a_slEnumerationItemsMode.Add( "lightModelViewMatrix" );
         a_slEnumerationItemsMode.Add( "Computes the ModelView matrix from the Light's point of view." );
         a_slEnumerationItemsMode.Add( "lightProjectionCameraMatrix" );
         a_slEnumerationItemsMode.Add( "Computes the ModelView matrix from the Light's point of view." );
         a_slEnumerationItemsMode.Add( "lightProjectionMatrix" );
         a_slEnumerationItemsMode.Add( "Computes the Projection matrix from the Light's point of view." );
         a_slEnumerationItemsMode.Add( "lightProjectionMatrixInverse" );
         a_slEnumerationItemsMode.Add( "Computes the Projection matrix from the Light's point of view and then inverts it." );
         a_slEnumerationItemsMode.Add( "lightViewMatrix" );
         a_slEnumerationItemsMode.Add( "Computes the View matrix from the Light's point of view." );
         a_slEnumerationItemsMode.Add( "lightViewMatrixLocal" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "lightMatrixLocal" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightModelViewCameraMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is undocumented at present.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightModelViewCameraMatrixNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightModelViewMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is undocumented at present.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightModelViewMatrixNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightProjectionCameraMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is undocumented at present.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightProjectionCameraMatrixNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightProjectionMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is undocumented at present.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightProjectionMatrixNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightStackNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node collects light references from the RenderInfo and builds variables for each light. If this node is linked to a UniformBufferNode or StructNode, these data structures are crawled and all variable nodes are computed for each light being managed by the LightStackNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "LightStackNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Light Structure", a_sNodeRefPropertyType, "", "This property should be linked to a UniformBufferNode or StructNode that contain variable nodes that extract Light parameters." );

         DataMemberNode a_oEnumeratedPropertyEnumerateActiveLightCount = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enumerate Active Light Count", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsEnumerateActiveLightCount;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyEnumerateActiveLightCount, a_slEnumerationItemsEnumerateActiveLightCount, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LightVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a VectorNode that can compute values based on the parameters of the Light node to which this node is connected. Alternatively, this node can compute values for Light nodes referenced by a LightStackNode that has a relationship with a UniformBufferNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "LightVectorNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "lightClipPlanes" );
         a_slEnumerationItemsMode.Add( "Computes the Light data source's near and far clip planes and stores the results in a vec2." );
         a_slEnumerationItemsMode.Add( "lightPosition" );
         a_slEnumerationItemsMode.Add( "Computes the Light data source's position and stores the results in a vec4." );
         a_slEnumerationItemsMode.Add( "lightDirection" );
         a_slEnumerationItemsMode.Add( "Computes Light data source's direction and stores the results in a vec4." );
         a_slEnumerationItemsMode.Add( "lightTransformationX" );
         a_slEnumerationItemsMode.Add( "Computes the X component of the Light's transformation matrix." );
         a_slEnumerationItemsMode.Add( "lightTransformationY" );
         a_slEnumerationItemsMode.Add( "Computes the Y component of the Light's transformation matrix." );
         a_slEnumerationItemsMode.Add( "lightTransformationZ" );
         a_slEnumerationItemsMode.Add( "Computes the Z component of the Light's transformation matrix." );
         a_slEnumerationItemsMode.Add( "lightTransformationT" );
         a_slEnumerationItemsMode.Add( "Computes the W component of the Light's transformation matrix." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LinearCircle_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates a linear curve in the shape of a circle from the center point and radius clicks defined by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "LinearCircle_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ListNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ListNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LoftPrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier implements curve-based lofting.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "LoftPrimitive" );

         DataMemberNode a_oEnumeratedPropertyFlowTextureWidth = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Flow Texture Width", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsFlowTextureWidth;
         a_slEnumerationItemsFlowTextureWidth.Add( "Along Outline" );
         a_slEnumerationItemsFlowTextureWidth.Add( "Flows the texture width along the loft input curves." );
         a_slEnumerationItemsFlowTextureWidth.Add( "Along Sweep" );
         a_slEnumerationItemsFlowTextureWidth.Add( "Flows the texture width perpendicular to the loft input curves." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyFlowTextureWidth, a_slEnumerationItemsFlowTextureWidth, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Default Material", a_sNodeRefPropertyType, "", "DEPRECATED. Use per-curve-segment Materials instead." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Cross Section Texture Start", a_sFloatPropertyType, "", "For tiling between cross-sections, this is the tiling origin relative to texture coordinates. 0 is typical." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Cross Section Texture End", a_sFloatPropertyType, "", "For tiling between cross-sections, this is the tiling origin relative to texture coordinates. 1 is typical." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Cross Section Curve Group", a_sNodeRefPropertyType, "", "A Group containing the set of curves you wish to loft." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "LoopNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "LoopNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MainFunctionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type implements a MainFunctionNode, which is the void main(void) {} declaration for a shader.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "MainFunctionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Material" )
      {
         // Document the node.
         string a_sTypeDocumentation = "Material nodes are used to define renderable surface parameters for faces or meshes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Material" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture Node Or Group Of Texture Nodes", a_sNodeRefPropertyType, "", "A Texture or a Group containing Textures." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On Render Data Source", a_sNodeRefPropertyType, "", "A Group of uniform VariableNodes that are publicly available to subsequent instances of this Material. These uniforms are bound when the Material/Program is selected during traversal." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Generic Data Source", a_sNodeRefPropertyType, "", "A node that serves as a generic data source. This node is not used at render time, but can be useful for extending relationships between Materials and other nodes." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Program Link or Link to Program Node", a_sNodeRefPropertyType, "", "A Program or a NodeLink&#187;Program that contains the shaders for the Material." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Solid Render", a_sBoolPropertyType, "", "Determines whether or not the Material is rendered as a solid color or with texturing. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Ambient Color", a_sColorPropertyType, "", "Sets the Material's ambient color. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Diffuse Color", a_sColorPropertyType, "", "Sets the Material's diffuse color. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Specular Color", a_sColorPropertyType, "", "Sets the Material's specular color. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Emissive Color", a_sColorPropertyType, "", "Sets the Material's emissive color. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shininess", a_sFloatPropertyType, "", "Sets the Material's shininess. This option must be implemented per-shader." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Identification Color", a_sColorPropertyType, "", "Sets the Material's identification color. This color is used to implement per-segment colors for curves and to render Material wireframes." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Feature Identification Integer", a_sIntPropertyType, "", "Sets the Material's feature identification integer. Range is 0-65536. This can be used to identify a Material, such as for deferred shading, or to select polygon faces by Feature ID." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Clamp S", a_sBoolPropertyType, "", "Clamps the texture boundary texels to absolute border along S [U]. ( DEPRECATED. Options are in Texture )" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Clamp T", a_sBoolPropertyType, "", "Clamps the texture boundary texels to absolute border along T [V]. ( DEPRECATED. Options are in Texture )" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Transparent", a_sBoolPropertyType, "", "Sets the Material to render with alpha blending, provided the associated shader Program supports this feature." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture Transparency", a_sBoolPropertyType, "", "Sets the Material to use texture transparency. ( DEPRECATED. This option is now a shader Program feature." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Opacity", a_sFloatPropertyType, "", "Sets the amount of opacity when <b>Transparent</b> is <b>true</b>. Range is between <b>0</b> and <b>1</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Alpha Reference", a_sFloatPropertyType, "", "Sets the opacity rejection threshold. When this parameter is enabled, texels above or below the specified alpha range are not rendered. Range is between <b>0</b> and <b>1</b>." );

         DataMemberNode a_oEnumeratedPropertyAlphaTestFunction = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Alpha Test Function", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsAlphaTestFunction;
         a_slEnumerationItemsAlphaTestFunction.Add( "No Test" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Does not perform any alpha threshold rejection." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Less Than Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels less than the <b>Alpha Reference</b> value." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Less Than Or Equal To Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels equal to or less than the <b>Alpha Reference</b> value." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Equal To Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels equal to the <b>Alpha Reference</b> value." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Not Equal To Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels not equal to the <b>Alpha Reference</b> value." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Greater Than Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels great than the <b>Alpha Reference</b> value." );
         a_slEnumerationItemsAlphaTestFunction.Add( "Reject Texels Greater Than Or Equal To Reference" );
         a_slEnumerationItemsAlphaTestFunction.Add( "Rejects texels equal to or greater the <b>Alpha Reference</b> value." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyAlphaTestFunction, a_slEnumerationItemsAlphaTestFunction, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Image Writes Enabled", a_sBoolPropertyType, "", "Determines whether or not to render faces to which this Material is applied." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material Is Two-Sided", a_sBoolPropertyType, "", "Determines whether or not to render faces even if the face is back-facing." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "HSR Writes Enabled", a_sBoolPropertyType, "", "Determines whether or not to include faces to which this Material is applied in z-buffer calculations.For example: Conserves rendering bandwidth when rendering skyboxes because there is geometry behind the skybox." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "HSR Tests Enabled", a_sBoolPropertyType, "", "Determines whether or not to test pixel depths before rendering." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "MaterialArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialColorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a ColorNode that can compute values based on the parameters of the Material node to which this node is connected. Alternatively, this node can compute values for Material nodes acquired from the RenderInfo.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "MaterialColorNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "materialAmbientColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's ambient color." );
         a_slEnumerationItemsMode.Add( "materialDiffuseColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's diffuse color." );
         a_slEnumerationItemsMode.Add( "materialSpecularColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's specular color." );
         a_slEnumerationItemsMode.Add( "materialEmissiveColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's emissive color." );
         a_slEnumerationItemsMode.Add( "materialIdentificationColor" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's identification color." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialFloatNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a FloatNode that can compute values based on the parameters of the Material node to which this node is connected. Alternatively, this node can compute values for Material nodes acquired from the RenderInfo.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "MaterialFloatNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "materialOpacity" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's opacity value." );
         a_slEnumerationItemsMode.Add( "materialShininess" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's shininess value." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialIntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an IntegerNode that can compute values based on the parameters of the Material node to which this node is connected. Alternatively, this node can compute values for Material nodes acquired from the RenderInfo.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "MaterialIntegerNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "materialIdentificationInteger" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's identification integer." );
         a_slEnumerationItemsMode.Add( "materialIsTransparent" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's transparency state." );
         a_slEnumerationItemsMode.Add( "materialImageWritesEnabled" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>Image Writes Enabled</b> state." );
         a_slEnumerationItemsMode.Add( "materialIsTwoSided" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>Material Is Two Sided</b> state." );
         a_slEnumerationItemsMode.Add( "material_HSR_WritesEnabled" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>HSR Writes Enabled</b> state." );
         a_slEnumerationItemsMode.Add( "material_HSR_TestsEnabled" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>HSR Tests Enabled</b> state." );
         a_slEnumerationItemsMode.Add( "materialClampS" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>Clamp S</b> state." );
         a_slEnumerationItemsMode.Add( "materialClampT" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>Clamp T</b> state." );
         a_slEnumerationItemsMode.Add( "materialAlphaTestFunction" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the Material data source's <b>Alpha Test Function</b> state." );
         a_slEnumerationItemsMode.Add( "materialWireframe" );
         a_slEnumerationItemsMode.Add( "This option is reserved for future use." );
         a_slEnumerationItemsMode.Add( "materialFilled" );
         a_slEnumerationItemsMode.Add( "This option is reserved for future use." );
         a_slEnumerationItemsMode.Add( "materialSolid" );
         a_slEnumerationItemsMode.Add( "This option is reserved for future use." );
         a_slEnumerationItemsMode.Add( "materialTextured" );
         a_slEnumerationItemsMode.Add( "This option is reserved for future use." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier applies a material to the selected face-set.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "MaterialModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Apply This Material", a_sNodeRefPropertyType, "", "The material to apply to the face-set referenced by this modifier." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MaterialPaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "MaterialPaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MatrixArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "MatrixArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MatrixExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements a vector expression node capable of creating matrix expressions from scalar, vector, or matrix variables. This expression can also generate R valued expressions such as mat2( 1.0, 0.0, 0.0, 1.0 ) if a VariableNode data source is not provided. This node cannot generate an R value expression on the left side of an assignment ( = ) operator because GLSL does not support that concept.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "", "MatrixExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a single matrix ( this is a mat2, mat3, mat4, mat3x4, etc. type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "MatrixNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Rows", a_sIntPropertyType, "", "Sets the number of rows in the matrix. Range is <b>1</b> to <b>4</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Columns", a_sIntPropertyType, "", "Sets the number of columns in the matrix. Range is <b>1</b> to <b>4</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Matrix Index 1,1, Matrix Index 1,2, Matrix Index 1,3 ...", a_sFloatPropertyType, "", "Allows you to view and specify matrix values. Value display is column-major." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MenuElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "MenuElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MergeFacesModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier merges the face-set of the referenced mesh with this mesh.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "MergeFacesModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Merge This Source Mesh", a_sNodeRefPropertyType, "", "The mesh to merge with this current mesh." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Mesh" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a mesh capable of storing vertex, edge, and face data-sets in a winged-edge format.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Mesh" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Group of Material Nodes", a_sNodeRefPropertyType, "", "Specifies the Group containing Materials used by the Mesh." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertices", a_sBoolPropertyType, "", "Toggles this Mesh's vertex display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertex Normals", a_sBoolPropertyType, "", "Toggles this Mesh's vertex normal display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Face Normals", a_sBoolPropertyType, "", "Toggles this Mesh's face normal display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Edges", a_sBoolPropertyType, "", "Toggles this Mesh's edge display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Hidden Edges", a_sBoolPropertyType, "", "Toggles this Mesh's hidden edge display." );

         DataMemberNode a_oEnumeratedPropertyCollisions = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Collisions", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCollisions;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCollisions, a_slEnumerationItemsCollisions, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On Render Data Source", a_sNodeRefPropertyType, "", "A Group or renderable node that you wish to render when the Mesh renders." );

         DataMemberNode a_oEnumeratedPropertyType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsType;
         a_slEnumerationItemsType.Add( "Position" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to vertex position. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Normal" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex normal. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Color" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex color. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Texture Coordinates" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex texture coordinates. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Integer Data" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store integer data. This is derived from AddChannelModifiers in the mesh construction history." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyType, a_slEnumerationItemsType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dimension", a_sIntPropertyType, "", "The dimension of the attribute channel. This is derived from AddChannelModifiers in the mesh construction history." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Modifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "The modifier is a base node for all other modifiers. It is never used directly.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "Modifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable", a_sBoolPropertyType, "", "Enables or disables the modifier. If the modifier generates geometry ( such as through edge-splitting ) disabling it can cause unusual downstream changes in the mesh construction history." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "MoveToVertex_TrackPlaneDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode has been deprecated.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "MoveToVertex_TrackPlaneDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Navigate_DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode sets the software to navigate mode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Navigate_DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Node" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is the base class for all Scenome application nodes. You generally do not use objects of type Node in the graph directly ( although you can if you wish ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Node" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Name", a_sStringPropertyType, "", "Sets the name of the node. Do not use / or \ [forward slash and backslash] in the node name as this produces conflicts with resolving link nodes that reference external files." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Class", a_sStringPropertyType, "", "Sets the class of the node." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "ID", a_sStringPropertyType, "", "Sets the ID of the node. This must be unique for each document, but different documents can use the same ID." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Export Disabled", a_sBoolPropertyType, "", "Determines whether or not the node is exported during an export process, such as to OpenSceneGraph." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "GUID", a_sStringPropertyType, "", "Enumerates the node's GUID." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "NodeLink" )
      {
         // Document the node.
         string a_sTypeDocumentation = "NodeLinks implement the concept of included content at the level of node.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "NodeLink" );

         DataMemberNode a_oEnumeratedPropertyNodeType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Node Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsNodeType;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyNodeType, a_slEnumerationItemsNodeType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Point At A Node In This File", a_sNodeRefPropertyType, "", "The node at which the NodeLink points." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Point At This .BOX File", a_sFilePathPropertyType, "", "An absolute or relative path to a .BOX file on the hard disk. Relative path is best practice." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Point At A Node In This File", a_sFilePathPropertyType, "", "The graph address of the node at which the NodeLink points. For example: /Material/MyMaterial" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Load Unique Copy", a_sBoolPropertyType, "", "If several NodeLinks refer to the same file, the model cache loads a single copy. This parameter provides an override in order to load a unique copy into the model cache." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "NormalTranslateModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier implements translation along the normal ( or averaged normal ) of a vertex, edge, or face ( or set of any of these ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "NormalTranslateModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "OperatorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a generic operator. User-level functionality is implemented by UnaryOperatorNode and BinaryOperatorNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "OperatorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "OrthoProjectionMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a matrix that can collect an orthographic projection from its data source ( another matrix ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "OrthoProjectionMatrixNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Source", a_sNodeRefPropertyType, "", "The matrix data source from which you wish to collect the orthographic projection." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "PaintAttributes_DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows the user to paint vertex color and alpha onto meshes with a compatible shader.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "PaintAttributes_DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ParameterListNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ParameterListNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ParametricMesh" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a mesh capable of storing vertex, edge, and face data-sets in a winged-edge format.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ParametricMesh" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Group of Material Nodes", a_sNodeRefPropertyType, "", "Specifies the Group containing Materials used by the Mesh." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertices", a_sBoolPropertyType, "", "Toggles this Mesh's vertex display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertex Normals", a_sBoolPropertyType, "", "Toggles this Mesh's vertex normal display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Face Normals", a_sBoolPropertyType, "", "Toggles this Mesh's face normal display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Edges", a_sBoolPropertyType, "", "Toggles this Mesh's edge display." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Hidden Edges", a_sBoolPropertyType, "", "Toggles this Mesh's hidden edge display." );

         DataMemberNode a_oEnumeratedPropertyCollisions = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Collisions", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsCollisions;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyCollisions, a_slEnumerationItemsCollisions, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On Render Data Source", a_sNodeRefPropertyType, "", "A Group or renderable node that you wish to render when the Mesh renders." );

         DataMemberNode a_oEnumeratedPropertyType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsType;
         a_slEnumerationItemsType.Add( "Position" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to vertex position. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Normal" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex normal. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Color" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex color. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Texture Coordinates" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store vertex texture coordinates. This is derived from AddChannelModifiers in the mesh construction history." );
         a_slEnumerationItemsType.Add( "Integer Data" );
         a_slEnumerationItemsType.Add( "Sets the attribute channel to store integer data. This is derived from AddChannelModifiers in the mesh construction history." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyType, a_slEnumerationItemsType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dimension", a_sIntPropertyType, "", "The dimension of the attribute channel. This is derived from AddChannelModifiers in the mesh construction history." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Path" )
      {
         // Document the node.
         string a_sTypeDocumentation = "Path nodes implement linear and Bezier curves. Paths serve a variety of functions but are primarily used for modeling loft and sweep geometry.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Path" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Group of Material Nodes", a_sNodeRefPropertyType, "", "Specifies the Group containing Material nodes used by the path." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "The Material used by the segment when the segment produces geometry." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tessellation Depth", a_sIntPropertyType, "", "The tessellation depth of the segment, which is the number of sub-fragments." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Texture Coordinate", a_sFloatPropertyType, "", "The starting texture coordinate of the segment." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Texture Coordinate", a_sFloatPropertyType, "", "The ending texture coordinate of the segment." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Length", a_sFloatPropertyType, "", "The length of the segment. This property is enumerated and cannot be changed." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "The X axis position of the point." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "The Y axis position of the point." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "The Z axis position of the point." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Heading", a_sFloatPropertyType, "", "Displays the start heading for the curve segment." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Pitch", a_sFloatPropertyType, "", "Displays the start pitch for the curve segment." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Heading", a_sFloatPropertyType, "", "Displays the end heading for the curve segment." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Pitch", a_sFloatPropertyType, "", "Displays the end pitch for the curve segment." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "PlanarProjectTexturePrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier projects the texture coordinate attributes for the selected attributes channel.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "PlanarProjectTexturePrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Origin X", a_sFloatPropertyType, "", "Sets the X axis origin of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Origin Y", a_sFloatPropertyType, "", "Sets the Y axis origin of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Origin Z", a_sFloatPropertyType, "", "Sets the Z axis origin of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Width Axis X", a_sFloatPropertyType, "", "Sets the X axis width of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Width Axis Y", a_sFloatPropertyType, "", "Sets the Y axis width of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Width Axis Z", a_sFloatPropertyType, "", "Sets the Z axis width of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Height Axis X", a_sFloatPropertyType, "", "Sets the X axis height of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Height Axis Y", a_sFloatPropertyType, "", "Sets the Y axis height of the projection in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Height Axis Z", a_sFloatPropertyType, "", "Sets the Z axis height of the projection in world coordinates." );

         DataMemberNode a_oEnumeratedPropertyMaterialFilter = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material Filter", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMaterialFilter;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMaterialFilter, a_slEnumerationItemsMaterialFilter, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type is a sub-node type. It is used to implement a command menu for curve-points ( since a point-selection is not a &lt;lNode&gt; ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "PopupElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "PopupElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "PreprocessorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements preprocessor settings for GLSL code generation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "PreprocessorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Program" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A Program node is linked to two or ASCII file containing a GLSL vertex, control, evaluation, geometry, or fragment shader program. Programs are bound when a mesh is rendered by way of the mesh's materials being connected to one or more Program nodes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "Program" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertex Program File", a_sFilePathPropertyType, "", "An absolute or relative path to the vertex shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tessellation Control Program File", a_sFilePathPropertyType, "", "An absolute or relative path to the tessellation control shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tessellation Evaluation Program File", a_sFilePathPropertyType, "", "The absolute or relative path to the tessellation evaluation shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Geometry Program File", a_sFilePathPropertyType, "", "The absolute or relative path to the geometry shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Fragment Program File", a_sFilePathPropertyType, "", "The absolute or relative path to the fragment shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pre-Compile Data Source", a_sNodeRefPropertyType, "", "A node that you wish to traverse before the Program is rendered." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "On Render Data Source", a_sNodeRefPropertyType, "", "A node that you wish to traverse when the Program is rendered." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Geometry Program Input Topology", a_sFilePathPropertyType, "", "Deprecated. Use shader-based layout options." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Geometry Program Output Topology", a_sNodeRefPropertyType, "", "Deprecated. Use shader-based layout options." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Geometry Program Max Vertices", a_sNodeRefPropertyType, "", "Deprecated. Use shader-based layout options." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ProgramOptions" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node facilitates the multi-compilation unit feature of OpenGL, as well as providing a means by which to change uniform values at traversal time.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ProgramOptions" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ProgramVariationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node provides a method of specifying an additional source code file for use with multiple program compilation. These nodes are placed as children of ProgramOptions nodes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ProgramVariationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ProjectionModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier enables geographic projection from latitude/longitude coordinates to Universal Transverse Mercator, Lambert Conformal Conic, or Robinson projection. This modifier is rarely used directly. Use the subclasses GeographicProjectionModifier and GeographicTextureModifier.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "ProjectionModifier" );

         DataMemberNode a_oEnumeratedPropertyProjection = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Projection", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsProjection;
         a_slEnumerationItemsProjection.Add( "Universal Transverse Mercator" );
         a_slEnumerationItemsProjection.Add( "Sets the projection to Universal Transverse Mercator." );
         a_slEnumerationItemsProjection.Add( "Lambert Conformal Conic" );
         a_slEnumerationItemsProjection.Add( "Sets the projection to Lambert Conformal Conic." );
         a_slEnumerationItemsProjection.Add( "Robinson" );
         a_slEnumerationItemsProjection.Add( "Sets the projection to Robinson." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyProjection, a_slEnumerationItemsProjection, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyDatum = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Datum", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsDatum;
         a_slEnumerationItemsDatum.Add( "WGS 84" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to World Geodetic Survey 1984." );
         a_slEnumerationItemsDatum.Add( "WGS 72" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to World Geodetic Survey 1972." );
         a_slEnumerationItemsDatum.Add( "Clarke 1866" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to Clarke 1866." );
         a_slEnumerationItemsDatum.Add( "Clarke 1880" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to Clarke 1880." );
         a_slEnumerationItemsDatum.Add( "Bessel" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to Bessel." );
         a_slEnumerationItemsDatum.Add( "GRS 80" );
         a_slEnumerationItemsDatum.Add( "Sets the datum to Geodetic Reference System 1980." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyDatum, a_slEnumerationItemsDatum, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "UTM Zone", a_sIntPropertyType, "", "This sets the UTM zone. This parameter is available when the projection is Universal Transverse Mercator" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "First Standard Parallel", a_sFloatPropertyType, "", "Sets the first standard parallel of the projection. Range is from -90 to 90. This value tends to be the lowest latitude value of the area being projected. This parameter is available when the projection is Lambert Conformal Conic." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Second Standard Parallel", a_sFloatPropertyType, "", "Sets the second standard parallel of the projection. Range is from -90 to 90. This value tends to be the highest latitude value of the area being projected. This parameter is available when the projection is Lambert Conformal Conic." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Central Meridian", a_sFloatPropertyType, "", "Sets the central meridian. Range is from -180 to 180. This value tends to be the center longitude value of the area being projected. This parameter is available when the projection is Lambert Conformal Conic or Robinson." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Origin Latitude", a_sFloatPropertyType, "", "Sets the origin latitude, which is the lowest latitude in the geographic area being projected. This parameter is available when the projection is Lambert Conformal Conic." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Easting", a_sFloatPropertyType, "", "Sets the false easting value for the projection. Range is from -100,000,000,000 to 100,000,000,000. This parameter is available when the projection is Lambert Conformal Conic." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Northing", a_sFloatPropertyType, "", "Sets the false northing value for the projection. Range is from -100,000,000,000 to 100,000,000,000. This parameter is available when the projection is Lambert Conformal Conic." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "QualifierNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node is used to as a container for OpenGL qualifiers and is not used directly.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "QualifierNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RectangleCreate_CurveDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode creates rectangle formed by linear curve segments that occupy the space from the lower-left corner click to the upper-right corner click provided by the user.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "RectangleCreate_CurveDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RectanglePrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the RectanglePrimitive, which produces tessellated geometry in the form of a polygon sheet.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "RectanglePrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum X", a_sFloatPropertyType, "", "The minimum X axis extent of the rectangle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Minimum Y", a_sFloatPropertyType, "", "The minimum Y axis extent of the rectangle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum X", a_sFloatPropertyType, "", "The maximum X axis extent of the rectangle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Maximum Y", a_sFloatPropertyType, "", "The maximum Y axis extent of the rectangle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "Links the modifier to a Material. This applies the Material to all the faces in the rectangle." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "X Resolution", a_sIntPropertyType, "", "Sets the rectangle's tessellation on the X axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Y Resolution", a_sIntPropertyType, "", "Sets the rectangle's tessellation on the Y axis." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Triangulate", a_sBoolPropertyType, "", "Determines whether or not the rectangle's triangle edges are hidden." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RectanglePrimitiveVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a VectorNode that can compute values based on the parameters of the RectangleGeometryModifier to which it is connected.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "RectanglePrimitiveVectorNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "rectangleGeometryModifierExtents" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the RectangleGeometryModifier's worldspace extents into a vec4." );
         a_slEnumerationItemsMode.Add( "rectangleGeometryTessellation" );
         a_slEnumerationItemsMode.Add( "Sets the mode to compute the RectangleGeometryModifier's X and Y tessellation values into a vec2." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RemoveChannelModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier removes the selected mesh attribute channel.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "RemoveChannelModifier" );

         DataMemberNode a_oEnumeratedPropertyChannel1 = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Channel 1", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsChannel1;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyChannel1, a_slEnumerationItemsChannel1, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RenderStateNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node takes control of database rendering upon traversal. Traversal then returns to the beginning of the document. Use subclasses such as ScreenAlignedGeometryNode or RenderTraversalNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "RenderStateNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable", a_sBoolPropertyType, "", "Determines whether or not the node is activated when it is traversed during rendering." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "RenderTraversalNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node takes control of database rendering upon traversal. Traversal then returns to the beginning of the document. This node allows you to implement a rendering technique that contains one or more passes.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "RenderTraversalNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable", a_sBoolPropertyType, "", "Determines whether or not the node is activated when it is traversed during rendering." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Rotate_SelectDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to interactively rotate the selected objects based on feedback provided by left clicking and dragging the rotate manipulator.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Rotate_SelectDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SamplerExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "SamplerExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SamplerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a sampler ( this is a sampler2D, sampler3D, etc. type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "SamplerNode" );

         DataMemberNode a_oEnumeratedPropertySamplerType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Sampler Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsSamplerType;
         a_slEnumerationItemsSamplerType.Add( "None" );
         a_slEnumerationItemsSamplerType.Add( "Sets the mode to none." );
         a_slEnumerationItemsSamplerType.Add( "sampler1D" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler1D." );
         a_slEnumerationItemsSamplerType.Add( "sampler2D" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler2D." );
         a_slEnumerationItemsSamplerType.Add( "sampler3D" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler3D." );
         a_slEnumerationItemsSamplerType.Add( "samplerCube" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to samplerCube." );
         a_slEnumerationItemsSamplerType.Add( "sampler1DShadow" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler1DShadow." );
         a_slEnumerationItemsSamplerType.Add( "sampler2DShadow" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler2DShadow." );
         a_slEnumerationItemsSamplerType.Add( "sampler2DArray" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to sampler2DArray." );
         a_slEnumerationItemsSamplerType.Add( "samplerCubeArray" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to samplerCubeArray." );
         a_slEnumerationItemsSamplerType.Add( "samplerCubeShadow" );
         a_slEnumerationItemsSamplerType.Add( "Sets the sampler type to samplerCubeShadow." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertySamplerType, a_slEnumerationItemsSamplerType, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ScalarExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ScalarExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Scale_ManipulateMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to interactively scale the selected objects based on feedback provided by left clicking and dragging the scale manipulator.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Scale_ManipulateMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ScreenAlignedGeometryNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a screen aligned quad.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ScreenAlignedGeometryNode" );

         DataMemberNode a_oEnumeratedPropertyScalingMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scaling Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsScalingMode;
         a_slEnumerationItemsScalingMode.Add( "None" );
         a_slEnumerationItemsScalingMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsScalingMode.Add( "Pixels" );
         a_slEnumerationItemsScalingMode.Add( "Sets scaling mode to pixels." );
         a_slEnumerationItemsScalingMode.Add( "Percent" );
         a_slEnumerationItemsScalingMode.Add( "Sets scaling mode to percent of screen width." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyScalingMode, a_slEnumerationItemsScalingMode, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyVerticalAlignment = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vertical Alignment", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsVerticalAlignment;
         a_slEnumerationItemsVerticalAlignment.Add( "Top" );
         a_slEnumerationItemsVerticalAlignment.Add( "Sets vertical alignment to top." );
         a_slEnumerationItemsVerticalAlignment.Add( "Center" );
         a_slEnumerationItemsVerticalAlignment.Add( "Sets vertical alignment to center." );
         a_slEnumerationItemsVerticalAlignment.Add( "Bottom" );
         a_slEnumerationItemsVerticalAlignment.Add( "Sets vertical alignment to bottom." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyVerticalAlignment, a_slEnumerationItemsVerticalAlignment, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyHorizontalAlignment = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Horizontal Alignment", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsHorizontalAlignment;
         a_slEnumerationItemsHorizontalAlignment.Add( "Left" );
         a_slEnumerationItemsHorizontalAlignment.Add( "Sets horizontal alignment to left." );
         a_slEnumerationItemsHorizontalAlignment.Add( "Center" );
         a_slEnumerationItemsHorizontalAlignment.Add( "Sets horizontal alignment to center." );
         a_slEnumerationItemsHorizontalAlignment.Add( "Right" );
         a_slEnumerationItemsHorizontalAlignment.Add( "Sets horizontal alignment to right." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyHorizontalAlignment, a_slEnumerationItemsHorizontalAlignment, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Margin Left", a_sFloatPropertyType, "", "The left margin in pixels or percent, depending the current <b>Scaling Mode</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Margin Top", a_sFloatPropertyType, "", "The top margin in pixels or percent, depending the current <b>Scaling Mode</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Margin Right", a_sFloatPropertyType, "", "The right margin in pixels or percent, depending the current <b>Scaling Mode</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Margin Bottom", a_sFloatPropertyType, "", "The bottom margin in pixels or percent, depending the current <b>Scaling Mode</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "ModelViewMatrix", a_sNodeRefPropertyType, "", "An optional ModelViewMatrix." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "ProjectionMatrix", a_sNodeRefPropertyType, "", "An optional ProjectionMatrix." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ScriptNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A ScriptNode is linked to an ASCII file containing a script that is invoked when the specified event takes place.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ScriptNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable", a_sBoolPropertyType, "", "Toggles the ScriptNode on/off." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Script Source Code File", a_sFilePathPropertyType, "", "An absolute or relative path to the script source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "OnRender Function", a_sStringPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "OnModelChanged Function", a_sStringPropertyType, "", "Undocumented at present." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "OnNotify Function", a_sStringPropertyType, "", "Undocumented at present." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Script_DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to create and bind custom editing actions to mouse buttons and drag actions.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Script_DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SectionConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A SectionConfigNode allows you to specify an InnoSetup&#174; script section, such as [Setup] or [Files]. FileConfigNodes and InstallerDirectiveNodes enumerate different properties based on their SectionConfigNode parent.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "SectionConfigNode" );

         DataMemberNode a_oEnumeratedPropertySection = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Section", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsSection;
         a_slEnumerationItemsSection.Add( "[Code]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[Components]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[Dirs]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[Files]" );
         a_slEnumerationItemsSection.Add( "Specifies a section that contains the files you wish to install." );
         a_slEnumerationItemsSection.Add( "[Icons]" );
         a_slEnumerationItemsSection.Add( "Specifies a section that contains the icons you wish to install." );
         a_slEnumerationItemsSection.Add( "[INI]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[InstallDelete]" );
         a_slEnumerationItemsSection.Add( "Specifies which files to delete prior to installation." );
         a_slEnumerationItemsSection.Add( "[LangOptions]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains language and font options." );
         a_slEnumerationItemsSection.Add( "[Languages]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains language and message file information." );
         a_slEnumerationItemsSection.Add( "[Messages]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[Registry]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains registry directives." );
         a_slEnumerationItemsSection.Add( "[Run]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains directives that start an application after installation is complete." );
         a_slEnumerationItemsSection.Add( "[Setup]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains basic setup directives such as company information, application information, and wizard information." );
         a_slEnumerationItemsSection.Add( "[Tasks]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[Types]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         a_slEnumerationItemsSection.Add( "[UninstallDelete]" );
         a_slEnumerationItemsSection.Add( "Specifies the section that contains directives that should occur during uninstall." );
         a_slEnumerationItemsSection.Add( "[UninstallRun]" );
         a_slEnumerationItemsSection.Add( "Unsupported at present." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertySection, a_slEnumerationItemsSection, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type is a sub-node type. It is used to implement a command menu for curve-segments ( since a segment-selection is not a &lt;lNode&gt; ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Select_SelectDrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to interactively select items on the worksheet that are the type set by the selection filter ( light, face, edges, curve, etc. ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Select_SelectDrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SeparatorElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "SeparatorElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderBufferBindNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ShaderBufferBindNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderBufferNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a shader buffer ( SSBO ) representation that can have child variables ( and child struct instances ) that can be bound to the GPU by a ShaderBufferBindNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ShaderBufferNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderCommentNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a comment.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderCommentNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Comment", a_sStringPropertyType, "", "The comment you wish to include in the shader source code." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use Fancy Header", a_sBoolPropertyType, "", "Uses a fancy header ( the type of which is determined during shader code generation )." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ShaderDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderDefineNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a a GLSL preprocessor #define declaration.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderDefineNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Identifier", a_sStringPropertyType, "", "This string stores the identifier component of the declaration: <b>#define identifier replacement</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Replacement", a_sStringPropertyType, "", "This string stores the replacement component of the declaration: <b>#define identifier replacement</b>." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderEndifNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ShaderEndifNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderIfndefNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ShaderIfndefNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderImportNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements up to four references that can import additional data into a shader code generation context.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderImportNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderIncludeNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a a GLSL preprocessor #include declaration.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderIncludeNode" );

         DataMemberNode a_oEnumeratedPropertyEnclosureFlag = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enclosure Flag", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsEnclosureFlag;
         a_slEnumerationItemsEnclosureFlag.Add( "<Angle Brackets>" );
         a_slEnumerationItemsEnclosureFlag.Add( "Encloses the #include filename in angle brackets. For example: <filename.glsl>." );
         a_slEnumerationItemsEnclosureFlag.Add( "\"Quotes\"" );
         a_slEnumerationItemsEnclosureFlag.Add( "Encloses the #include filename in quotation marks. For example: \"filename.glsl\"." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyEnclosureFlag, a_slEnumerationItemsEnclosureFlag, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Include Filename", a_sStringPropertyType, "", "The filename you wish to include, such as <b>shading_functions.glsl</b>." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderPaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ShaderPaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderPragmaNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a a GLSL preprocessor #pragma declaration.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderPragmaNode" );

         DataMemberNode a_oEnumeratedPropertyPragma = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pragma", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsPragma;
         a_slEnumerationItemsPragma.Add( "optimize(on)" );
         a_slEnumerationItemsPragma.Add( "This sets the pragma to optimize(on)." );
         a_slEnumerationItemsPragma.Add( "optimize(off)" );
         a_slEnumerationItemsPragma.Add( "This sets the pragma to optimize(off)." );
         a_slEnumerationItemsPragma.Add( "debug(on)" );
         a_slEnumerationItemsPragma.Add( "This sets the pragma to debug(on)." );
         a_slEnumerationItemsPragma.Add( "debug(off)" );
         a_slEnumerationItemsPragma.Add( "This sets the pragma to debug(off)." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyPragma, a_slEnumerationItemsPragma, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "A ShaderSourceNode specifies a shader stage, such as vertex or fragment. This node is used to implement separate shader stages ( and interface matching ) for GLSL code generation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderSourceNode" );

         DataMemberNode a_oEnumeratedPropertyRepresentingShaderStage = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Representing Shader Stage", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsRepresentingShaderStage;
         a_slEnumerationItemsRepresentingShaderStage.Add( "VertexShader" );
         a_slEnumerationItemsRepresentingShaderStage.Add( "Configures the shader stage to represent a vertex shader." );
         a_slEnumerationItemsRepresentingShaderStage.Add( "ControlShader" );
         a_slEnumerationItemsRepresentingShaderStage.Add( "Configures the shader stage to represent a tessellation control shader." );
         a_slEnumerationItemsRepresentingShaderStage.Add( "EvaluationShader" );
         a_slEnumerationItemsRepresentingShaderStage.Add( "Configures the shader stage to represent a tessellation evaluation shader." );
         a_slEnumerationItemsRepresentingShaderStage.Add( "GeometryShader" );
         a_slEnumerationItemsRepresentingShaderStage.Add( "Configures the shader stage to represent a geometry shader." );
         a_slEnumerationItemsRepresentingShaderStage.Add( "FragmentShader" );
         a_slEnumerationItemsRepresentingShaderStage.Add( "Configures the shader stage to represent a fragment shader." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyRepresentingShaderStage, a_slEnumerationItemsRepresentingShaderStage, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Program Data Source", a_sNodeRefPropertyType, "", "The program for which the ShaderSourceNode is managing code generation." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Previous Shader Stage", a_sNodeRefPropertyType, "", "A ShaderSourceNode for the previous shader stage." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Next Shader Stage", a_sNodeRefPropertyType, "", "A ShaderSourceNode for the next shader stage." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderUndefNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a a GLSL preprocessor #undef declaration.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderUndefNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Undef This #define", a_sNodeRefPropertyType, "", "Connect this data source to the ShaderDefineNode you wish to undefine." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ShaderVersionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a a GLSL preprocessor #version declaration.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "ShaderVersionNode" );

         DataMemberNode a_oEnumeratedPropertyShadingLanguageVersion = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Shading Language Version", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsShadingLanguageVersion;
         a_slEnumerationItemsShadingLanguageVersion.Add( "110" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 110." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "120" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 120." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "130" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 130." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "140" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 140." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "150" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 150." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "330" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 330." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "400" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 400." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "410" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 410." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "420" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 420." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "430" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 430." );
         a_slEnumerationItemsShadingLanguageVersion.Add( "440" );
         a_slEnumerationItemsShadingLanguageVersion.Add( "Sets the shading language version to #version 440." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyShadingLanguageVersion, a_slEnumerationItemsShadingLanguageVersion, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SimplifyModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier implements mesh simplification.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SimplifyModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Reduction Percent", a_sFloatPropertyType, "", "The amount of geometry you wish to remove. Range is <strong>0</strong> to <strong>100</strong>." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SmoothModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "When applied to vertices, this modifier smoothes vertex positions without adding extra geometry by using subdivision surface mathematics to reposition the vertices. When applied to faces, this modifier smooths the geometry by using subdivision surface mathematics to smooth the geometry.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SmoothModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SpherePrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements the SpherePrimitive, which produces tessellated geometry in the form of a sphere.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SpherePrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center X", a_sFloatPropertyType, "", "Sets the sphere's center position on the X axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center Y", a_sFloatPropertyType, "", "Sets the sphere's center position on the Y axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Center Z", a_sFloatPropertyType, "", "Sets the sphere's center position on the Z axis in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Radius", a_sFloatPropertyType, "", "Sets the sphere's radius in world coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Material", a_sNodeRefPropertyType, "", "Links the modifier to a Material. This applies the Material to all the faces in the sphere." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Longitude Resolution", a_sIntPropertyType, "", "Sets the sphere's tessellation around its equator." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Latitude Resolution", a_sIntPropertyType, "", "Sets the sphere's tessellation from its south pole to its north pole." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Triangulate", a_sBoolPropertyType, "", "Determines whether or not the sphere's triangle edges are hidden." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Apply Texture Modifier", a_sBoolPropertyType, "", "Determines whether or not the sphere is used to project texture coordinates." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Longitude Texture", a_sFloatPropertyType, "", "This parameter sets the starting texture wrap position around the sphere from east-to-west." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Start Latitude Texture", a_sFloatPropertyType, "", "This parameter sets the starting texture wrap along the sphere from south-to-north." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Longitude Texture", a_sFloatPropertyType, "", "This parameter sets the ending texture wrap position around the sphere from east-to-west." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "End Latitude Texture", a_sFloatPropertyType, "", "This parameter sets the ending texture wrap along the sphere from south-to-north." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StatementBlockNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "StatementBlockNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StencilNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements StencilBuffer controls ( which function at traversal time ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "StencilNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable Stencil", a_sBoolPropertyType, "", "Toggles the stencil on/off." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Two-Sided", a_sBoolPropertyType, "", "Toggles the stencil one or two-sided." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StringArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "StringArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StringNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements storage for string data.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "StringNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StructExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "StructExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StructInstanceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "StructInstanceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "StructNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a Struct parameter container for GLSL code generation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "StructNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SubdivideQuadModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier regularly subdivides all the quads in a mesh.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SubdivideQuadModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SubroutineIntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an IntegerNode that can control which variation of a subroutine is invoked. The variable name must match the subroutine name.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SubroutineIntegerNode" );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "Subroutine Variation" );
         a_slEnumerationItemsMode.Add( "Sets the mode to select the subroutine variation at the index specified by this node's integer value." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SubroutineListNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "SubroutineListNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SubroutineNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "SubroutineNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "SweepPrimitive" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier produces geometry by sweeping its input cross section curves along its input rail curve.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "SweepPrimitive" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pitch Geometry To Follow Curve", a_sBoolPropertyType, "", "This option aligns the swept geometry with the pitch of the curve." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Transform Geometry From Origin", a_sBoolPropertyType, "", "This option toggles the transform frame-of-reference from the origin to rail and sweep curve coordinates. This option should generally be <b>True</b." );

         DataMemberNode a_oEnumeratedPropertyFlowTextureWidth = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Flow Texture Width", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsFlowTextureWidth;
         a_slEnumerationItemsFlowTextureWidth.Add( "Along Outline" );
         a_slEnumerationItemsFlowTextureWidth.Add( "Flows the texture width along the curve." );
         a_slEnumerationItemsFlowTextureWidth.Add( "Along Sweep" );
         a_slEnumerationItemsFlowTextureWidth.Add( "Flows the texture width perpendicular to the curve." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyFlowTextureWidth, a_slEnumerationItemsFlowTextureWidth, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Default Material", a_sNodeRefPropertyType, "", "DEPRECATED. Use per-curve-segment Materials instead." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Cross Section Curve Group", a_sNodeRefPropertyType, "", "A Group containing the set of curves you wish to sweep along the rail curves." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Rail Curve Group", a_sNodeRefPropertyType, "", "A Group containing the set of curves you along which you wish to sweep the cross-section curves." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TerrainOptionsModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for configuring GIS terrain generation options.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "TerrainOptionsModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Use Preview Imagery", a_sBoolPropertyType, "", "This option determines whether or not a preview texture is created from ortho-imagery." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Imagery Directory", a_sFilePathPropertyType, "", "An absolute or relative path to the directory containing GEOTIFF ortho-imagery." );

         DataMemberNode a_oEnumeratedPropertyPreviewTextureWidth = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Preview Texture Width", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsPreviewTextureWidth;
         a_slEnumerationItemsPreviewTextureWidth.Add( "64" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 64 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "128" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 128 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "256" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 256 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "512" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 512 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "1024" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 1024 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "2048" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 2048 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "4096" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 4096 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "8192" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 8192 pixels." );
         a_slEnumerationItemsPreviewTextureWidth.Add( "16384" );
         a_slEnumerationItemsPreviewTextureWidth.Add( "Sets the preview texture width to 16384 pixels." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyPreviewTextureWidth, a_slEnumerationItemsPreviewTextureWidth, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyPreviewTextureHeight = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Preview Texture Height", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsPreviewTextureHeight;
         a_slEnumerationItemsPreviewTextureHeight.Add( "64" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 64 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "128" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 128 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "256" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 256 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "512" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 512 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "1024" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 1024 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "2048" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 2048 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "4096" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 4096 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "8192" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 8192 pixels." );
         a_slEnumerationItemsPreviewTextureHeight.Add( "16384" );
         a_slEnumerationItemsPreviewTextureHeight.Add( "Sets the preview texture height to 16384 pixels." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyPreviewTextureHeight, a_slEnumerationItemsPreviewTextureHeight, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Imagery Directory", a_sFilePathPropertyType, "", "An absolute or relative path to the directory containing GEOTIFF ortho-imagery." );

         DataMemberNode a_oEnumeratedPropertyOutputTextureWidth = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Output Texture Width", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsOutputTextureWidth;
         a_slEnumerationItemsOutputTextureWidth.Add( "64" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 64 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "128" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 128 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "256" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 256 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "512" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 512 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "1024" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 1024 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "2048" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 2048 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "4096" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 4096 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "8192" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 8192 pixels." );
         a_slEnumerationItemsOutputTextureWidth.Add( "16384" );
         a_slEnumerationItemsOutputTextureWidth.Add( "Sets the output texture width to 16384 pixels." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyOutputTextureWidth, a_slEnumerationItemsOutputTextureWidth, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyOutputTextureHeight = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Output Texture Height", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsOutputTextureHeight;
         a_slEnumerationItemsOutputTextureHeight.Add( "64" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 64 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "128" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 128 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "256" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 256 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "512" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 512 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "1024" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 1024 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "2048" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 2048 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "4096" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 4096 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "8192" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 8192 pixels." );
         a_slEnumerationItemsOutputTextureHeight.Add( "16384" );
         a_slEnumerationItemsOutputTextureHeight.Add( "Sets the output texture height to 16384 pixels." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyOutputTextureHeight, a_slEnumerationItemsOutputTextureHeight, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Texture" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for configuring GIS terrain generation options.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GIS", "C++", "Texture" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Generate MIP Maps", a_sBoolPropertyType, "", "Toggles MIP map generation. This option should be <b>True</b> whenever possible, as it can greatly reduce sampling costs and improve shader performance." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture Is External", a_sBoolPropertyType, "", "Toggles external texture state. External textures reference a file on the hard disk. External textures are best practice." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture File", a_sBoolPropertyType, "", "For an external texture, an absolute or relative path to the texture file on disk. Relative paths are best practice." );

         DataMemberNode a_oEnumeratedPropertyPixelFormat = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pixel Format", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsPixelFormat;
         a_slEnumerationItemsPixelFormat.Add( "8 I" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 8-bit indexed. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "8 A" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 8-bit indexed. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "1555 ARGB" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 1555 ARGB. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "565 RGB" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 565 RGB. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "888 RGB" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 888 RGB. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "8888 ARGB" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 8888 ARGB. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "4444 ARGB" );
         a_slEnumerationItemsPixelFormat.Add( "This option is enumerated when the pixel format is 4444 ARGB. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "32-Bit Depth" );
         a_slEnumerationItemsPixelFormat.Add( "This option sets the texture to 32-bit depth with 8-bit stencil. Valid only when texture is a child of a BufferNode." );
         a_slEnumerationItemsPixelFormat.Add( "32-Bit Depth, 8-Bit Stencil" );
         a_slEnumerationItemsPixelFormat.Add( "This option sets the texture to 32-bit depth with 8-bit stencil. Valid only when texture is a child of a BufferNode." );
         a_slEnumerationItemsPixelFormat.Add( "3x 10-Bit RGB, 2-Bit Alpha" );
         a_slEnumerationItemsPixelFormat.Add( "This option sets the texture to 30-bit RGB, 2-bit Alpha. This option can be set for internal textures." );
         a_slEnumerationItemsPixelFormat.Add( "F16 R" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F16 RG" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F16 RGB" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F16 RGBA" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F32 R" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F32 RG" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F32 RGB" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         a_slEnumerationItemsPixelFormat.Add( "F32 RGBA" );
         a_slEnumerationItemsPixelFormat.Add( "Undocumented at present." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyPixelFormat, a_slEnumerationItemsPixelFormat, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyTextureType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Texture Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTextureType;
         a_slEnumerationItemsTextureType.Add( "2D" );
         a_slEnumerationItemsTextureType.Add( "This option flags the texture as a 2D texture." );
         a_slEnumerationItemsTextureType.Add( "3D" );
         a_slEnumerationItemsTextureType.Add( "This option flags the texture as a 3D texture." );
         a_slEnumerationItemsTextureType.Add( "Cube Map" );
         a_slEnumerationItemsTextureType.Add( "This option flags the texture as a cube map." );
         a_slEnumerationItemsTextureType.Add( "Render Buffer" );
         a_slEnumerationItemsTextureType.Add( "This option flags the texture as a render buffer. Texture file path is ignored. This texture is always internal." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTextureType, a_slEnumerationItemsTextureType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Array Size", a_sIntPropertyType, "", "This option sets the array size of the texture ( the number of slices ). Valid only when texture type is <b>2D</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Source X", a_sFloatPropertyType, "", "This option sets the texture source coordinates. Range is 0 to the max width of the texture." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Source Y", a_sFloatPropertyType, "", "This option sets the texture source coordinates. Range is 0 to the max height of the texture." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Width", a_sFloatPropertyType, "", "This option sets the texture width coordinates. Range is 0 to the max width of the texture." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Height", a_sFloatPropertyType, "", "This option sets the texture height coordinates. Range is 0 to the max height of the texture." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Render Width", a_sFloatPropertyType, "", "This option sets the actual rendered width of the texture regardless of its source and width/height parameters." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Render Width", a_sFloatPropertyType, "", "This option sets the actual rendered height of the texture regardless of its source and width/height parameters." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Render Depth", a_sIntPropertyType, "", "This option sets the number of slices for a 3D texture. Valid only when texture type is <b>3D</b>." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Export Subdivide", a_sBoolPropertyType, "", "This option is reserved for future use." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Export File", a_sFilePathPropertyType, "", "This option is reserved for future use." );

         DataMemberNode a_oEnumeratedPropertyTileS = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tile S", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTileS;
         a_slEnumerationItemsTileS.Add( "Clamp" );
         a_slEnumerationItemsTileS.Add( "This option clamps texture tiling on S." );
         a_slEnumerationItemsTileS.Add( "Repeat" );
         a_slEnumerationItemsTileS.Add( "This option allows texture tiling on S to repeat." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTileS, a_slEnumerationItemsTileS, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyTileT = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tile T", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTileT;
         a_slEnumerationItemsTileT.Add( "Clamp" );
         a_slEnumerationItemsTileT.Add( "This option clamps texture tiling on T." );
         a_slEnumerationItemsTileT.Add( "Repeat" );
         a_slEnumerationItemsTileT.Add( "This option allows texture tiling on T to repeat." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTileT, a_slEnumerationItemsTileT, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyTileR = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Tile R", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTileR;
         a_slEnumerationItemsTileR.Add( "Clamp" );
         a_slEnumerationItemsTileR.Add( "This option clamps texture tiling on R." );
         a_slEnumerationItemsTileR.Add( "Repeat" );
         a_slEnumerationItemsTileR.Add( "This option allows texture tiling on R to repeat." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTileR, a_slEnumerationItemsTileR, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TextureArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "TextureArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TextureCoordsModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier projects the texture coordinate attributes for the selected attributes channel.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "TextureCoordsModifier" );

         DataMemberNode a_oEnumeratedPropertyChannel1 = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Channel 1", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsChannel1;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyChannel1, a_slEnumerationItemsChannel1, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TexturePaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "TexturePaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TimerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a FloatNode that can compute timing values.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "TimerNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Enable", a_sBoolPropertyType, "", "Toggles timing computation on/off." );

         DataMemberNode a_oEnumeratedPropertyMode = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Mode", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMode;
         a_slEnumerationItemsMode.Add( "None" );
         a_slEnumerationItemsMode.Add( "Sets the mode to none." );
         a_slEnumerationItemsMode.Add( "timerMilliseconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerMilliseconds[0_1]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerMilliseconds[0_2PI]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSeconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSeconds[0_1]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSeconds[0_2PI]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerCosSeconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSinSeconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerTanSeconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerCosSeconds[0_1]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSinSeconds[0_1]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerTanSeconds[0_1]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerCosSeconds[0_2PI]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerSinSeconds[0_2PI]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerTanSeconds[0_2PI]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerFrameStart_Milliseconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerFrameStart_Seconds[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerFrameIndex[0_X]" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         a_slEnumerationItemsMode.Add( "timerFramesPerSecond" );
         a_slEnumerationItemsMode.Add( "Undocumented at present." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMode, a_slEnumerationItemsMode, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Interval", a_sIntPropertyType, "", "This option is undocumented at present." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ToggleVertexSpokeEdgesModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier shows/hides the spoke edges emanating from a vertex.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "ToggleVertexSpokeEdgesModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ToolbarElementNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ToolbarElementNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TransformFeedbackLayoutNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a parameter container for configuring transform feedback shader layout options.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "TransformFeedbackLayoutNode" );

         DataMemberNode a_oEnumeratedPropertyxfb_buffer = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_buffer", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsxfb_buffer;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyxfb_buffer, a_slEnumerationItemsxfb_buffer, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyxfb_offset = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_offset", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsxfb_offset;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyxfb_offset, a_slEnumerationItemsxfb_offset, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyxfb_stride = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_stride", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsxfb_stride;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyxfb_stride, a_slEnumerationItemsxfb_stride, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_buffer value", a_sIntPropertyType, "", "Sets the xfb_buffer index value." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_offset value", a_sIntPropertyType, "", "Sets the xfb_offset value." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "xfb_stride value", a_sIntPropertyType, "", "Sets the xfb_stride value." );

         DataMemberNode a_oEnumeratedPropertyout = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "out", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsout;
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyout, a_slEnumerationItemsout, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TransformModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier translates, scales, and rotates geometry.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "TransformModifier" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pivot X", a_sFloatPropertyType, "", "Sets the X axis transform pivot position." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pivot Y", a_sFloatPropertyType, "", "Sets the Y axis transform pivot position." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Pivot Z", a_sFloatPropertyType, "", "Sets the Z axis transform pivot position." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position X", a_sFloatPropertyType, "", "Sets the X axis position transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Y", a_sFloatPropertyType, "", "Sets the Y axis position transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Position Z", a_sFloatPropertyType, "", "Sets the Z axis position transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation X", a_sFloatPropertyType, "", "Sets the X axis orientation transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Y", a_sFloatPropertyType, "", "Sets the Y axis orientation transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Orientation Z", a_sFloatPropertyType, "", "Sets the Z axis orientation transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale X", a_sFloatPropertyType, "", "Sets the X axis scale transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale Y", a_sFloatPropertyType, "", "Sets the Y axis scale transform." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Scale Z", a_sFloatPropertyType, "", "Sets the Z axis scale transform." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Translate_ManipulateMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to interactively translate the selected objects based on feedback provided by left clicking and dragging the translate manipulator.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Translate_ManipulateMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TraversalGuardNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "TraversalGuardNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TriangulateModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier triangulates any non-triangular geometry.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "TriangulateModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TurnEdgeModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier switches the central edge shared by two triangles from the initial pair of vertices to the other pair of vertices.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "TurnEdgeModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TypeAggregatorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node has been deprecated. Included for compatibility purposes only.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "TypeAggregatorNode" );
         a_oTypeRepNode.TypeStatus = 1;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TypeConfigNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a container for storing TypeRepNodes that allow you to design and implement node type documentation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "TypeConfigNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "TypeRepNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node allows you to create a graph-based representation of a type &lt;T&gt;, including its inheritance, editable properties ( or data members ), and documentation.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "EDITTOOLS", "C++", "TypeRepNode" );

         DataMemberNode a_oEnumeratedPropertyNodeElement = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Node Element", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsNodeElement;
         a_slEnumerationItemsNodeElement.Add( "None" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type will not be a node element ( such as a &lt;Mesh&gt; face or &lt;Curve&gt; segment )." );
         a_slEnumerationItemsNodeElement.Add( "Face" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to a mesh face." );
         a_slEnumerationItemsNodeElement.Add( "Edge" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to a mesh edge." );
         a_slEnumerationItemsNodeElement.Add( "Vertex" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to a mesh vertex." );
         a_slEnumerationItemsNodeElement.Add( "Segment" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to a curve segment." );
         a_slEnumerationItemsNodeElement.Add( "Point" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to a curve point." );
         a_slEnumerationItemsNodeElement.Add( "Generic" );
         a_slEnumerationItemsNodeElement.Add( "Specifies that the type refers to multiple types." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyNodeElement, a_slEnumerationItemsNodeElement, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type &lt;T&gt;", a_sStringPropertyType, "", "The type name for which the TypeRepNode serves as an alias during layout." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Documentation", a_sStringPropertyType, "", "A short description of the type." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Module", a_sStringPropertyType, "", "The module ( DLL or executable ) in which the type is implemented. The module name should be fully capitalized." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Implementation", a_sStringPropertyType, "", "The language in which the implementation is written ( C++ )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Implementation", a_sStringPropertyType, "", "The language in which the implementation is written ( C++ )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Data Interface Name", a_sStringPropertyType, "", "The data interface name of the type. Usually the same as the type name &lt;T&gt; given above." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Super Class Data Source", a_sNodeRefPropertyType, "", "A link to another TypeRepNode for the type that is the superclass. For types derived from Node, Node is usually the ultimate superclass, but Type may be given as well." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Definition Data Source", a_sNodeRefPropertyType, "", "A link to another TypeRepNode if this TypeRepNode is serving as an instance of a particular Type &lt;T&gt;." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Documentation Path", a_sStringPropertyType, "", "An absolute or relative path to extended documentation ( usually .TXT, .HTM, .STM ) on the disk." );

         DataMemberNode a_oEnumeratedPropertyTypeStatus = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Type Status", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsTypeStatus;
         a_slEnumerationItemsTypeStatus.Add( "Deprecated" );
         a_slEnumerationItemsTypeStatus.Add( "Marks the type as deprecated, which means it should no longer be used and any instances of it should be replaced." );
         a_slEnumerationItemsTypeStatus.Add( "Compatibility" );
         a_slEnumerationItemsTypeStatus.Add( "Marks the type for compatibility, which means it can be used if it exists but you should not create new instances of this type." );
         a_slEnumerationItemsTypeStatus.Add( "Active" );
         a_slEnumerationItemsTypeStatus.Add( "Marks the type for active, which means it can be used without reservation." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyTypeStatus, a_slEnumerationItemsTypeStatus, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Is Final Type", a_sBoolPropertyType, "", "Marks the type as final, which means that it will get a command menu when interface definitions are regenerated." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UniformArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UniformArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UniformBufferBindNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node binds a uniform buffer to the GPU when the Program node under which it is parented is selected for rendering.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "UniformBufferBindNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Uniform Buffer Slot Index", a_sIntPropertyType, "", "Sets the slot index for the uniform buffer. All uniform buffer slot index parameters must use sequential values starting at 0 or the buffer may not bind properly." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "UniformBufferNode Data Source", a_sIntPropertyType, "", "The UniformBufferNode you wish to bind. Can be in the same document, or in a different document and bound via NodeLink." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UniformBufferNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a uniform buffer that can have child variables ( and child struct instances ) that can be bound to the GPU by a UniformBufferBindNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "UniformBufferNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UniformPaletteNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UniformPaletteNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerVectorArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerVectorArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerVectorArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerVectorArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerVectorExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerVectorExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "UnsignedIntegerVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "UnsignedIntegerVectorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VariableArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements an array container for variables used by subclasses such as ColorArrayNode and VectorArrayNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VariableArrayNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VariableExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements expression functionality. It is a generic superclass used by subclasses such as BooleanExpressionNode and VectorExpressionNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VariableExpressionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Expression Item Count", a_sIntPropertyType, "", "This flag stores the number of child items for a constructor or function expression. Not applicable to any expression that does not have child expressions. DEBUG USE ONLY." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Operator Data Source", a_sNodeRefPropertyType, "", "This option allows you to set an operator data source ( such as a UnaryOperatorNode, BinaryOperatorNode, or TernaryOperatorNode )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Variable Data Source", a_sStringPropertyType, "", "This option enumerates the name of VariableNode that serves as the data source for the expression. You cannot edit the input VariableNode with this property item." );

         DataMemberNode a_oEnumeratedPropertyExpressionType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Expression Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsExpressionType;
         a_slEnumerationItemsExpressionType.Add( "Expression" );
         a_slEnumerationItemsExpressionType.Add( "This option configures the node as an expression, which means it generates a left or right value." );
         a_slEnumerationItemsExpressionType.Add( "Constructor" );
         a_slEnumerationItemsExpressionType.Add( "This option configures the node as a constructor, which means it calls a constructor function such as vec4( float ). Constructor expression types must have at least one child." );
         a_slEnumerationItemsExpressionType.Add( "Function" );
         a_slEnumerationItemsExpressionType.Add( "This option configures the node as a function, which means it calls a function such as mix(). Function expression types may or may not have any child expression items." );
         a_slEnumerationItemsExpressionType.Add( "Function Parameter" );
         a_slEnumerationItemsExpressionType.Add( "This option configures the node as a function parameter, which means it must a child of a function or constructor expression." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyExpressionType, a_slEnumerationItemsExpressionType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Namespace and Array Access", a_sIntPropertyType, "", "<Variable Length Property> <int> This property item is displayed if the variable referenced by the expression is accessed through a Struct, Interface Block, Shader Buffer or Uniform Buffer. If the property item is an array, the property sheet displays an <int> property that enumerates the variable name and array dimension, which allows you to choose the array index to access. " );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Function Name", a_sStringPropertyType, "", "This option sets the name of the function call, such as mix(). Constructor expressions do not need a function name, as their function call is based off of the expression type. Therefore, a vec4 constructor will call vec4( param )." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Generated Code", a_sStringPropertyType, "", "This option enumerates the code generated by the expression ( except for constructor or function expressions ). You cannot edit an expression here." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VariableNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a container for variables used by subclasses such as ColorNode and VectorNode.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VariableNode" );

         DataMemberNode a_oEnumeratedPropertyBindingType = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Binding Type", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsBindingType;
         a_slEnumerationItemsBindingType.Add( "Local" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable without any qualifiers ( a local variable ). For example: 'vec4 myVec4'." );
         a_slEnumerationItemsBindingType.Add( "Const" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'const' qualifier. For example: 'const vec4 myVec4'." );
         a_slEnumerationItemsBindingType.Add( "Uniform" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'uniform' qualifier. For example: 'uniform vec4 myVec4'." );
         a_slEnumerationItemsBindingType.Add( "Attribute" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'attribute' qualifier. For example: 'attribute vec4 SPA_Position0'. Provided for compatibility." );
         a_slEnumerationItemsBindingType.Add( "Varying" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'varying' qualifier. For example: 'varying vec4 SPA_Position0'. Provided for compatibility." );
         a_slEnumerationItemsBindingType.Add( "Compile Directive" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'compiler directive' qualifier. This option is not compatible with GLSL, but is compatible with ProgramOptions." );
         a_slEnumerationItemsBindingType.Add( "In" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'in' qualifier. For example: 'in vec4 position'." );
         a_slEnumerationItemsBindingType.Add( "Out" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable with the 'out' qualifier. For example: 'out vec4 position'." );
         a_slEnumerationItemsBindingType.Add( "None" );
         a_slEnumerationItemsBindingType.Add( "This option declares a variable without any qualifier. For example: 'vec4 position'." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyBindingType, a_slEnumerationItemsBindingType, a_sEnumItemPropertyType );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Name Prefix", a_sStringPropertyType, "", "A variable name prefix, often used for a value that indicates a particular shader stage such as 'vs_', 'gs_', or 'fs_'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Variable Name", a_sStringPropertyType, "", "Sets the name of the variable. You should use the variable name only. To declare a variable named 'vec3 MyVector', you set this parameter to 'MyVector'." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Name Suffix", a_sStringPropertyType, "", "A variable name suffix, often used to indicate a specific array size such as [4], or to indicate an unsized array []." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VectorArrayExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "VectorArrayExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VectorArrayNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines and stores an array of vector values ( this is a vec4 type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VectorArrayNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Array Dimension", a_sIntPropertyType, "", "Sets the dimension of the array. Maximum array size is determined by the OpenGL implementation on the active hardware." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "X, Y, Z, W", a_sFloatPropertyType, "", "Sets the value for each vector component of the array." );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VectorExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This class implements a vector expression node capable of creating vector expressions from scalar, vector, or matrix variables. This expression can also generate R valued expressions such as vec4( 1.0, 0.0, 0.0, 1.0 ) if a VariableNode data source is not provided. This node cannot generate an R value expression on the left side of an assignment ( = ) operator because GLSL does not support that concept.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VectorExpressionNode" );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Dimension", a_sIntPropertyType, "", "This option enumerates the dimension of the vector expression, such as <b>3</b> for vec3. You cannot edit the dimension of expressions that are on the left or right side of an assignment ( = ) expression." );
         SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Matrix Options", a_sIntPropertyType, "", "This option allows you to choose which matrix column to select for vector construction. For example: mat4x4 myMatrix could result in myMatrix[0] or myMatrix[2]. This option is only available if the expression's data source is a MatrixNode." );

         DataMemberNode a_oEnumeratedPropertyVectorNotation = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vector Notation", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsVectorNotation;
         a_slEnumerationItemsVectorNotation.Add( "RGBA" );
         a_slEnumerationItemsVectorNotation.Add( "This values indicates RGBA notation using .r, .g, .b, and .a to access vector components 0 - 3." );
         a_slEnumerationItemsVectorNotation.Add( "XYZW" );
         a_slEnumerationItemsVectorNotation.Add( "This values indicates XYZW notation using .x, .y, .z, and .w to access vector components 0 - 3." );
         a_slEnumerationItemsVectorNotation.Add( "STPQ" );
         a_slEnumerationItemsVectorNotation.Add( "This values indicates STPQ notation using .s, .t, .p, and .q to access vector components 0 - 3." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyVectorNotation, a_slEnumerationItemsVectorNotation, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyMemberSelection = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Member Selection", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsMemberSelection;
         a_slEnumerationItemsMemberSelection.Add( "Member" );
         a_slEnumerationItemsMemberSelection.Add( "This value indicates the 0-th component of a vector, corresponding to .r, .x, or .s." );
         a_slEnumerationItemsMemberSelection.Add( "Member" );
         a_slEnumerationItemsMemberSelection.Add( "This value indicates the 1-th component of a vector, corresponding to .g, .y, or .t." );
         a_slEnumerationItemsMemberSelection.Add( "Member" );
         a_slEnumerationItemsMemberSelection.Add( "This value indicates the 2-th component of a vector, corresponding to .b, .z, or .p." );
         a_slEnumerationItemsMemberSelection.Add( "Member" );
         a_slEnumerationItemsMemberSelection.Add( "This value indicates the 3-th component of a vector, corresponding to .a, .w, or .q." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyMemberSelection, a_slEnumerationItemsMemberSelection, a_sEnumItemPropertyType );

         DataMemberNode a_oEnumeratedPropertyVectorComponents = SpaInterfaceUtil.CreatePropertySheetEntry( a_oTypeRepNode, "Vector Components", a_sEnumPropertyType, "", "" );
         auto StrList a_slEnumerationItemsVectorComponents;
         a_slEnumerationItemsVectorComponents.Add( "[0]" );
         a_slEnumerationItemsVectorComponents.Add( "This value indicates the 0-th component of a vector, corresponding to .r, .x, or .s. Used to construct R value expressions, or to fill in missing data during variable promotion ( such as vec4( vec2, 1.0, 1.0 ). " );
         a_slEnumerationItemsVectorComponents.Add( "[1]" );
         a_slEnumerationItemsVectorComponents.Add( "This value indicates the 1-th component of a vector, corresponding to .g, .y, or .t." );
         a_slEnumerationItemsVectorComponents.Add( "[2]" );
         a_slEnumerationItemsVectorComponents.Add( "This value indicates the 2-th component of a vector, corresponding to .b, .z, or .p." );
         a_slEnumerationItemsVectorComponents.Add( "[3]" );
         a_slEnumerationItemsVectorComponents.Add( "This value indicates the 3-th component of a vector, corresponding to .a, .w, or .q." );
         SpaInterfaceUtil.CreateEnumEntry( a_oEnumeratedPropertyVectorComponents, a_slEnumerationItemsVectorComponents, a_sEnumItemPropertyType );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a vector of floating point values ( this is a vec2, vec3, or vec4 type in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "VectorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This type is a sub-node type. It is used to implement a command menu for vertex-selections ( since a vertex-selection is not a &lt;lNode&gt; ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "None", "None", "" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VertexDeclarationNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "VertexDeclarationNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VertexSourceNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "VertexSourceNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ViewMatrixNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a variable that defines a matrix of floating point values ( this is a mat2, mat2x3, mat3, or mat4 type ( or other valid matrix type ) in GLSL ).";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ViewMatrixNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ViewStateNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "ViewStateNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = false;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ViewportFloatNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a FloatNode that can compute values based on the parameters of the current active view.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ViewportFloatNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "ViewportVectorNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This node implements a VectorNode that can compute values based on the parameters of the current active view.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "GEOMETRY", "C++", "ViewportVectorNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "VoidExpressionNode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "", "", "VoidExpressionNode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "WeldVertexModifier" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This modifier collapses the A vertex onto the B vertex. In any set of selected vertices, the A vertex is the first in the selection and the B vertex is the second.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "PARAMETRIC", "C++", "WeldVertexModifier" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
      else
      if( a_oTypeRepNode && a_oTypeRepNode.Name == "Zoom_DrawMode" )
      {
         // Document the node.
         string a_sTypeDocumentation = "This draw mode allows you to zoom in and out interactively, including toward the location of the cursor on-screen.";
         SpaInterfaceUtil.ConfigureTypeDocumentation( a_oTypeRepNode, a_oTypeRepNode.Name, a_sTypeDocumentation, "BASETOOLS", "C++", "Zoom_DrawMode" );
         a_oTypeRepNode.TypeStatus = 2;
         a_oTypeRepNode.IsFinalType = true;
      }
   }
}
